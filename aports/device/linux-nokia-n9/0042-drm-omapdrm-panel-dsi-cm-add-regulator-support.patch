From 581b6a4ba275643413107f6daee34e159949272e Mon Sep 17 00:00:00 2001
From: Sebastian Reichel <sre@kernel.org>
Date: Wed, 2 Mar 2016 17:44:45 +0100
Subject: [PATCH 42/53] drm: omapdrm: panel-dsi-cm: add regulator support

The N950's display requires two regulators.

Signed-off-by: Sebastian Reichel <sre@kernel.org>
---
 drivers/gpu/drm/omapdrm/displays/panel-dsi-cm.c | 57 +++++++++++++++++++++++--
 1 file changed, 53 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/omapdrm/displays/panel-dsi-cm.c b/drivers/gpu/drm/omapdrm/displays/panel-dsi-cm.c
index dc026a843712..539639f13f60 100644
--- a/drivers/gpu/drm/omapdrm/displays/panel-dsi-cm.c
+++ b/drivers/gpu/drm/omapdrm/displays/panel-dsi-cm.c
@@ -23,6 +23,7 @@
 #include <linux/workqueue.h>
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>

 #include <video/mipi_display.h>

@@ -59,6 +60,9 @@ struct panel_drv_data {
	int reset_gpio;
	int ext_te_gpio;

+	struct regulator *vpnl;
+	struct regulator *vddi;
+
	bool use_dsi_backlight;

	struct omap_dsi_pin_config pin_config;
@@ -596,25 +600,43 @@ static int dsicm_power_on(struct panel_drv_data *ddata)
		.lp_clk_max = 10000000,
	};

+	if (ddata->vpnl) {
+		r = regulator_enable(ddata->vpnl);
+		if (r) {
+			dev_err(&ddata->pdev->dev,
+				"failed to enable VPNL: %d\n", r);
+			goto err0;
+		}
+	}
+
+	if (ddata->vddi) {
+		r = regulator_enable(ddata->vddi);
+		if (r) {
+			dev_err(&ddata->pdev->dev,
+				"failed to enable VDDI: %d\n", r);
+			goto err1;
+		}
+	}
+
	if (ddata->pin_config.num_pins > 0) {
		r = in->ops.dsi->configure_pins(in, &ddata->pin_config);
		if (r) {
			dev_err(&ddata->pdev->dev,
				"failed to configure DSI pins\n");
-			goto err0;
+			goto err2;
		}
	}

	r = in->ops.dsi->set_config(in, &dsi_config);
	if (r) {
		dev_err(&ddata->pdev->dev, "failed to configure DSI\n");
-		goto err0;
+		goto err2;
	}

	r = in->ops.dsi->enable(in);
	if (r) {
		dev_err(&ddata->pdev->dev, "failed to enable DSI\n");
-		goto err0;
+		goto err2;
	}

	dsicm_hw_reset(ddata);
@@ -672,6 +694,12 @@ static int dsicm_power_on(struct panel_drv_data *ddata)
	dsicm_hw_reset(ddata);

	in->ops.dsi->disable(in, true, false);
+err2:
+	if (ddata->vddi)
+		regulator_disable(ddata->vddi);
+err1:
+	if (ddata->vpnl)
+		regulator_disable(ddata->vpnl);
 err0:
	return r;
 }
@@ -695,6 +723,11 @@ static void dsicm_power_off(struct panel_drv_data *ddata)

	in->ops.dsi->disable(in, true, false);

+	if (ddata->vddi)
+		regulator_disable(ddata->vddi);
+	if (ddata->vpnl)
+		regulator_disable(ddata->vpnl);
+
	ddata->enabled = 0;
 }

@@ -1130,7 +1163,7 @@ static int dsicm_probe_of(struct platform_device *pdev)
	struct device_node *node = pdev->dev.of_node;
	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
	struct omap_dss_device *in;
-	int gpio;
+	int gpio, err;

	gpio = of_get_named_gpio(node, "reset-gpios", 0);
	if (!gpio_is_valid(gpio)) {
@@ -1153,6 +1186,22 @@ static int dsicm_probe_of(struct platform_device *pdev)
		return PTR_ERR(in);
	}

+	ddata->vpnl = devm_regulator_get_optional(&pdev->dev, "vpnl");
+	if (IS_ERR(ddata->vpnl)) {
+		err = PTR_ERR(ddata->vpnl);
+		if (err == -EPROBE_DEFER)
+			return err;
+		ddata->vpnl = NULL;
+	}
+
+	ddata->vddi = devm_regulator_get_optional(&pdev->dev, "vddi");
+	if (IS_ERR(ddata->vddi)) {
+		err = PTR_ERR(ddata->vddi);
+		if (err == -EPROBE_DEFER)
+			return err;
+		ddata->vddi = NULL;
+	}
+
	ddata->in = in;

	/* TODO: ulps, backlight */
--
2.11.0
