From a299e9ef103c96ba83691ae5f913e0cb2e69fca9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Filip=20Matijevi=C4=87?= <filip.matijevic.pz@gmail.com>
Date: Sun, 29 Nov 2015 18:27:57 +0100
Subject: [PATCH 14/53] input: Add SPI vibra support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Adapted driver from Ilkka Koskinen <ilkka.koskinen@nokia.com>

Signed-off-by: Filip MatijeviÄ‡ <filip.matijevic.pz@gmail.com>
---
 drivers/input/misc/Kconfig     |   8 +
 drivers/input/misc/Makefile    |   1 +
 drivers/input/misc/vibra-spi.c | 366 +++++++++++++++++++++++++++++++++++++++++
 3 files changed, 375 insertions(+)
 create mode 100644 drivers/input/misc/vibra-spi.c

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 1ae4d9617ff8..1ba6fd96bab4 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -832,4 +832,12 @@ config INPUT_HISI_POWERKEY
	  To compile this driver as a module, choose M here: the
	  module will be called hisi_powerkey.

+config INPUT_VIBRA_SPI
+	tristate "Support for SPI driven Vibra module"
+	help
+	  Support for Vibra module that is connected to SPI bus.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vibra_spi.
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 0b6d025f0487..56c272afa1eb 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -73,6 +73,7 @@ obj-$(CONFIG_INPUT_TWL4030_PWRBUTTON)	+= twl4030-pwrbutton.o
 obj-$(CONFIG_INPUT_TWL4030_VIBRA)	+= twl4030-vibra.o
 obj-$(CONFIG_INPUT_TWL6040_VIBRA)	+= twl6040-vibra.o
 obj-$(CONFIG_INPUT_UINPUT)		+= uinput.o
+obj-$(CONFIG_INPUT_VIBRA_SPI)		+= vibra-spi.o
 obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
diff --git a/drivers/input/misc/vibra-spi.c b/drivers/input/misc/vibra-spi.c
new file mode 100644
index 000000000000..228f129131ec
--- /dev/null
+++ b/drivers/input/misc/vibra-spi.c
@@ -0,0 +1,366 @@
+/*
+ * This file implements a driver for SPI data driven vibrator.
+ *
+ * Copyright (C) 2010 Nokia Corporation
+ *
+ * Contact: Ilkka Koskinen <ilkka.koskinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+/* Number of effects handled with memoryless devices */
+#define WAVE_SIZE		156 /* In u32 */
+#define WAIT_TIMEOUT		10 /* In ms */
+
+#define FF_EFFECT_QUEUED	BIT(0)
+#define FF_EFFECT_PLAYING	BIT(1)
+#define FF_EFFECT_ABORTING	BIT(2)
+
+/* A pre-generated normalized sine-table for signal generation */
+static u8 sine_lookup[] = {
+	32, 32, 32, 32, 32, 32, 32, 31, 31, 31, 31, 30, 30, 30, 29, 29, 29, 28,
+	28, 27, 27, 27, 26, 26, 25, 24, 24, 23, 23, 22, 22, 21, 20, 20, 19, 18,
+	18, 17, 16, 16, 15, 15, 14, 13, 13, 12, 11, 11, 10, 10, 9, 8, 8, 7, 7,
+	6, 6, 5, 5, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
+	8, 8, 9, 10, 10, 11, 11, 12, 13, 13, 14, 15, 15, 16, 16, 17, 18, 18,
+	19, 20, 20, 21, 22, 22, 23, 23, 24, 24, 25, 26, 26, 27, 27, 27, 28, 28,
+	29, 29, 29, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32
+};
+
+enum vibra_status {
+	IDLE = 0,
+	STARTED,
+	PLAYING,
+	CLOSING,
+};
+
+struct vibra_effect_info {
+	char		*buf;
+	unsigned int	buflen;
+	unsigned long	flags;	/* effect state (STARTED, PLAYING, etc) */
+};
+
+struct vibra_data {
+	struct device			*dev;
+	struct input_dev		*input_dev;
+
+	struct workqueue_struct 	*workqueue;
+	struct work_struct		play_work;
+
+	struct spi_device		*spi_dev;
+	struct spi_transfer		t;
+	struct spi_message		msg;
+	u32				spi_max_speed_hz;
+
+	enum vibra_status		status;
+
+	struct vibra_effect_info	einfo;
+
+	wait_queue_head_t		wq;
+
+	int				gpio;
+};
+
+static int vibra_spi_raw_write_effect(struct vibra_data *vibra)
+{
+	spi_message_init(&vibra->msg);
+	memset(&vibra->t, 0, sizeof(vibra->t));
+
+	vibra->t.tx_buf	= vibra->einfo.buf;
+	vibra->t.len	= vibra->einfo.buflen;
+	spi_message_add_tail(&vibra->t, &vibra->msg);
+
+	return spi_sync(vibra->spi_dev, &vibra->msg);
+}
+
+static void vibra_play_work(struct work_struct *work)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	struct vibra_data *vibra = container_of(work,
+						struct vibra_data, play_work);
+	struct vibra_effect_info *curr = &vibra->einfo;
+	int ret;
+
+	add_wait_queue(&vibra->wq, &wait);
+	while (1) {
+		if (vibra->status == CLOSING)
+			goto switch_off;
+
+		if (curr->flags & FF_EFFECT_ABORTING)
+			goto switch_off;
+
+		spin_lock_bh(&vibra->input_dev->event_lock);
+		curr->flags |= FF_EFFECT_PLAYING;
+
+		spin_unlock_bh(&vibra->input_dev->event_lock);
+
+		if (vibra->status == STARTED) {
+			gpio_set_value(vibra->gpio, true);
+			usleep_range(1000, 1100);
+			vibra->status = PLAYING;
+		}
+
+		ret = vibra_spi_raw_write_effect(vibra);
+		if (ret < 0) {
+			dev_err(vibra->dev,
+				"Error replaying an effect: %d", ret);
+			goto switch_off;
+		}
+
+		continue;
+
+switch_off:
+		gpio_set_value(vibra->gpio, false);
+
+		curr->flags &= ~FF_EFFECT_PLAYING;
+		vibra->status = IDLE;
+		remove_wait_queue(&vibra->wq, &wait);
+		return;
+	}
+}
+
+
+/*
+ * Calculate sample table for vibra signal.
+ * Each 32bit sample forms one PWM duty cycle. The vibra is a speaker type vibra
+ * that needs 150Hz sine signal to give good vibration force. The wave form is
+ * created by doing a amplitude modulation with PWM. The wave form is always
+ * the same, but we control the strength by changing the amplitude.
+ */
+static void vibra_spi_create_signal(struct vibra_data *vibra,
+						struct ff_effect *effect)
+{
+	unsigned int i;
+	u16 strong, weak;
+	u32 gain, div = 0xffffffff / 32;
+	u32 *buf = (u32 *)vibra->einfo.buf;
+
+	strong = effect->u.rumble.strong_magnitude;
+	weak = effect->u.rumble.weak_magnitude;
+
+	gain = strong;
+	gain = gain << 16;
+	gain |= weak;
+	gain = gain / 32;
+
+	/* Calculate 32 bit PWM cycles for a sine signal */
+	for (i = 0; i < WAVE_SIZE; i++)
+		buf[i] = (1 << (sine_lookup[i] * gain / div)) - 1;
+
+}
+
+/*
+ * Input/Force feedback guarantees that playback() is called with spinlock held
+ * and interrupts off.
+ */
+static int vibra_spi_playback(struct input_dev *input, void *vibra_data,
+						struct ff_effect *ff_effect)
+{
+	struct vibra_data *vibra = (struct vibra_data *) vibra_data;
+	struct vibra_effect_info *einfo = &vibra->einfo;
+
+	if (!vibra->workqueue)
+		return -ENODEV;
+
+	if (!ff_effect->u.rumble.strong_magnitude &&
+					!ff_effect->u.rumble.weak_magnitude) {
+		/* Abort the given effect */
+		if (einfo->flags & FF_EFFECT_PLAYING)
+			einfo->flags |= FF_EFFECT_ABORTING;
+
+		einfo->flags &= ~FF_EFFECT_QUEUED;
+	} else {
+		einfo->flags |= FF_EFFECT_QUEUED;
+		einfo->flags &= ~FF_EFFECT_ABORTING;
+		vibra_spi_create_signal(vibra, ff_effect);
+
+		if (vibra->status == IDLE) {
+			vibra->status = STARTED;
+			queue_work(vibra->workqueue, &vibra->play_work);
+		}
+
+		wake_up_interruptible(&vibra->wq);
+	}
+
+	return 0;
+}
+
+static int vibra_spi_open(struct input_dev *input)
+{
+	struct vibra_data *vibra = input_get_drvdata(input);
+
+	vibra->workqueue = create_singlethread_workqueue("vibra");
+	if (!vibra->workqueue) {
+		dev_err(&input->dev, "couldn't create workqueue\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void vibra_spi_close(struct input_dev *input)
+{
+	struct vibra_data *vibra = input_get_drvdata(input);
+
+	vibra->status = CLOSING;
+
+	cancel_work_sync(&vibra->play_work);
+	INIT_WORK(&vibra->play_work, vibra_play_work);
+	destroy_workqueue(vibra->workqueue);
+	vibra->workqueue = NULL;
+
+	vibra->status = IDLE;
+}
+
+static int vibra_spi_probe(struct spi_device *spi)
+{
+	struct vibra_data *vibra;
+	int gpio;
+	int ret = -ENOMEM;
+
+	vibra = devm_kzalloc(&spi->dev, sizeof(*vibra), GFP_KERNEL);
+	if (!vibra) {
+		dev_err(&spi->dev, "Not enough memory");
+		return -ENOMEM;
+	}
+
+	gpio = of_get_named_gpio(spi->dev.of_node, "enable-gpio", 0);
+	if (gpio < 0) {
+		dev_err(&spi->dev,
+			"Failed to retrieve gpio from device tree\n");
+		return gpio;
+        }
+
+	ret = devm_gpio_request_one(&spi->dev, gpio,
+				GPIOF_OUT_INIT_HIGH, "vibra_spi_power");
+        if (ret) {
+                 dev_err(&spi->dev, "Failed to request power pin\n");
+                 return ret;
+        }
+	vibra->gpio = gpio;
+
+	vibra->spi_max_speed_hz = spi->max_speed_hz;
+
+	INIT_WORK(&vibra->play_work, vibra_play_work);
+	init_waitqueue_head(&vibra->wq);
+
+	vibra->dev = &spi->dev;
+	spi_set_drvdata(spi, vibra);
+	vibra->spi_dev = spi;
+
+	spi->bits_per_word = 32;
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(&spi->dev, "spi_setup failed");
+		goto err_spi_setup;
+	}
+
+	vibra->input_dev = input_allocate_device();
+	if (!vibra->input_dev) {
+		dev_err(vibra->dev, "couldn't allocate input device\n");
+		ret = -ENOMEM;
+		goto err_input_alloc;
+	}
+
+	input_set_drvdata(vibra->input_dev, vibra);
+
+	vibra->input_dev->name		= "SPI vibrator";
+	vibra->input_dev->id.version	= 1;
+	vibra->input_dev->dev.parent	= spi->dev.parent;
+	vibra->input_dev->open		= vibra_spi_open;
+	vibra->input_dev->close		= vibra_spi_close;
+
+	set_bit(FF_RUMBLE, vibra->input_dev->ffbit);
+
+	ret = input_ff_create_memless(vibra->input_dev, vibra,
+							vibra_spi_playback);
+	if (ret) {
+		dev_err(&spi->dev, "Couldn't create ff_memless device");
+		goto err_ff_memless_create;
+	}
+
+	ret = input_register_device(vibra->input_dev);
+	if (ret < 0) {
+		dev_dbg(&spi->dev, "couldn't register input device\n");
+		goto err_input_register;
+	}
+	vibra->einfo.buflen = sizeof(u32) * WAVE_SIZE;
+
+	vibra->einfo.buf = devm_kzalloc(&spi->dev, vibra->einfo.buflen, GFP_KERNEL);
+	if (!vibra->einfo.buf) {
+		dev_err(&spi->dev, "Not enough memory for sample table\n");
+		goto err_playbuf;
+	}
+
+	dev_dbg(&spi->dev, "SPI driven Vibra driver initialized\n");
+	return 0;
+err_playbuf:
+	input_unregister_device(vibra->input_dev);
+err_input_register:
+	input_ff_destroy(vibra->input_dev);
+err_ff_memless_create:
+	input_free_device(vibra->input_dev);
+err_input_alloc:
+err_spi_setup:
+	return ret;
+}
+
+static int vibra_spi_remove(struct spi_device *spi)
+{
+	struct vibra_data *vibra = dev_get_drvdata(&spi->dev);
+
+	input_unregister_device(vibra->input_dev);
+
+	return 0;
+}
+
+static const struct of_device_id vibra_spi_of_match[] = {
+	{.compatible = "nokia,vibra-spi", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, vibra_spi_of_match);
+
+static struct spi_driver vibra_spi_driver = {
+	.driver = {
+		.name		= "vibra-spi",
+		.owner		= THIS_MODULE,
+		.of_match_table	= vibra_spi_of_match,
+	},
+	.probe		= vibra_spi_probe,
+	.remove		= vibra_spi_remove,
+};
+module_spi_driver(vibra_spi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ilkka Koskinen <ilkka.koskinen@nokia.com>");
+MODULE_ALIAS("spi:vibra_spi");
--
2.11.0
