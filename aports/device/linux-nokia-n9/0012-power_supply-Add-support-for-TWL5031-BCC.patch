From 3d833f4271d8383662fa03926f06771f91e5f928 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Filip=20Matijevi=C4=87?= <filip.matijevic.pz@gmail.com>
Date: Fri, 27 Nov 2015 19:57:29 +0100
Subject: [PATCH 12/53] power_supply: Add support for TWL5031 BCC
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

TI TWL5031 uses BCC (Battery Charger Control) instead of BCI (Battery
Charge Interface) found in TWL4030.
Driver originates from N9/N950 kernel by Aliaksei Katovich (Nokia) and
work of Philippe De Swert (Jolla)

Signed-off-by: Filip MatijeviÄ‡ <filip.matijevic.pz@gmail.com>
---
 drivers/mfd/twl-core.c                 |  13 +
 drivers/power/supply/Kconfig           |   7 +
 drivers/power/supply/Makefile          |   1 +
 drivers/power/supply/twl5031_charger.c | 600 +++++++++++++++++++++++++++++++++
 include/linux/i2c/twl.h                |   1 +
 5 files changed, 622 insertions(+)
 create mode 100644 drivers/power/supply/twl5031_charger.c

diff --git a/drivers/mfd/twl-core.c b/drivers/mfd/twl-core.c
index c64615dca2bd..7f10fb7e7bd0 100644
--- a/drivers/mfd/twl-core.c
+++ b/drivers/mfd/twl-core.c
@@ -1,3 +1,4 @@
+
 /*
  * twl_core.c - driver for TWL4030/TWL5030/TWL60X0/TPS659x0 PM
  * and audio CODEC devices
@@ -90,6 +91,7 @@
 #define TWL4030_BASEADD_KEYPAD		0x00D2

 #define TWL5031_BASEADD_ACCESSORY	0x0074 /* Replaces Main Charge */
+#define TWL5031_BASEADD_BCC             0x00AA /* Changed from TWL4030 */
 #define TWL5031_BASEADD_INTERRUPTS	0x00B9 /* Different than TWL4030's
						  one */

@@ -203,6 +205,7 @@ static struct twl_mapping twl4030_map[] = {
	{ 3, TWL4030_BASEADD_INT },

	{ 2, TWL5031_BASEADD_ACCESSORY },
+	{ 2, TWL5031_BASEADD_BCC },
	{ 2, TWL5031_BASEADD_INTERRUPTS },
 };

@@ -961,6 +964,16 @@ add_children(struct twl4030_platform_data *pdata, unsigned irq_base,
			return PTR_ERR(child);
	}

+	if (IS_ENABLED(CONFIG_CHARGER_TWL5031) && (features & TWL5031)) {
+		child = add_child(TWL5031_MODULE_BCC, "twl5031_bcc",
+				NULL, 0, false,
+				/* irq0 = CHG_PRES, irq1 = BCI */
+				irq_base + BCI_PRES_INTR_OFFSET,
+				irq_base + BCI_INTR_OFFSET);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
	if (IS_ENABLED(CONFIG_TWL4030_POWER) && pdata->power) {
		child = add_child(TWL_MODULE_PM_MASTER, "twl4030_power",
				  pdata->power, sizeof(*pdata->power), false,
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 76806a0be820..3c308c28cbf2 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -328,6 +328,13 @@ config CHARGER_TWL4030
	help
	  Say Y here to enable support for TWL4030 Battery Charge Interface.

+config CHARGER_TWL5031
+	tristate "TWL5031 Battery Charge Control driver"
+	depends on TWL4030_CORE
+	help
+	  Say Y to enable support for TWL5031 BCC.
+	  This driver enables VAC/USB chargers detection.
+
 config CHARGER_LP8727
	tristate "TI/National Semiconductor LP8727 charger driver"
	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 36c599d9a495..e4e0d21f515f 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -53,6 +53,7 @@ obj-$(CONFIG_AB8500_BM)		+= ab8500_bmdata.o ab8500_charger.o ab8500_fg.o ab8500_
 obj-$(CONFIG_CHARGER_ISP1704)	+= isp1704_charger.o
 obj-$(CONFIG_CHARGER_MAX8903)	+= max8903_charger.o
 obj-$(CONFIG_CHARGER_TWL4030)	+= twl4030_charger.o
+obj-$(CONFIG_CHARGER_TWL5031)   += twl5031_charger.o
 obj-$(CONFIG_CHARGER_LP8727)	+= lp8727_charger.o
 obj-$(CONFIG_CHARGER_LP8788)	+= lp8788-charger.o
 obj-$(CONFIG_CHARGER_GPIO)	+= gpio-charger.o
diff --git a/drivers/power/supply/twl5031_charger.c b/drivers/power/supply/twl5031_charger.c
new file mode 100644
index 000000000000..8378c4a34d36
--- /dev/null
+++ b/drivers/power/supply/twl5031_charger.c
@@ -0,0 +1,600 @@
+/*
+ * twl5031-charger.c - TWL5031 Battery Charge Control driver
+ *
+ * (C) 2010 Nokia Corporation
+ *
+ * Contact: Aliaksei Katovich <aliaksei.katovich@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/workqueue.h>
+#include <linux/power_supply.h>
+#include <linux/usb/phy.h>
+#include <linux/regulator/consumer.h>
+#include <linux/ulpi/regs.h>
+#include <linux/i2c/twl.h>
+
+#define TWL5031_BCC_CTRL2		0x01
+#define TWL5031_CHGMODE_SW		BIT(0)
+#define TWL5031_SW_USBCHRG_EN		BIT(1)
+#define TWL5031_SW_VACCHRG_EN		BIT(2)
+#define TWL5031_SW_CHRG_DET		BIT(3)
+#define TWL5031_SW_USB_DET_EN		BIT(4)
+
+#define TWL5031_BCC_STS			0x02
+#define TWL5031_USB_DET_STS_LO		BIT(0)
+#define TWL5031_USB_DET_STS_HI		BIT(1)
+#define TWL5031_USB_P_STS		BIT(2)
+#define TWL5031_VAC_P_STS		BIT(3)
+#define TWL5031_BATTERY_PRESENCE_STS	BIT(4)
+
+#define TWL5031_USB_CHRG_CTRL1		0x03
+#define TWL5031_USB_SW_CTRL_EN		BIT(0)
+#define TWL5031_CHGD_IDX_SRC_EN_LOWV	BIT(1)
+#define TWL5031_CHGD_VDX_SRC_EN_LOWV	BIT(2)
+#define TWL5031_CHGD_SERX_EN_LOWV	BIT(3)
+#define TWL5031_CHGD_VDX_LOWV		BIT(4)
+#define TWL5031_CHGD_SERX_DP_LOWV	BIT(5)
+#define TWL5031_CHGD_SERX_DM_LOWV	BIT(6)
+
+#define TWL5031_USB_CHRG_CTRL2		0x04
+#define TWL5031_USB_100			BIT(0)
+#define TWL5031_USB_500			BIT(1)
+
+#define TWL5031_LED_DRIVER_CTRL		0x05
+#define TWL5031_LEDC_DISABLE		0x08
+
+#define TWL5031_USB_DET_STS_100MA	1
+#define TWL5031_USB_DET_STS_500MA	2
+#define TWL5031_USB_DET_STS_MASK	(TWL5031_USB_DET_STS_LO | \
+					 TWL5031_USB_DET_STS_HI)
+
+struct twl5031_bcc_data {
+	/* device lock */
+	struct mutex			mutex;
+	struct device			*dev;
+	struct workqueue_struct 	*wq;
+	struct work_struct		work;
+	struct usb_phy			*otg;
+	struct notifier_block		nb;
+	struct regulator		*usb3v1;
+	struct power_supply		*usb;
+	struct power_supply_desc	usb_desc;
+	u8				usb_present:1;
+	u16				usb_current;	/* [mA] */
+	struct power_supply		*vac;
+	struct power_supply_desc	vac_desc;
+	u8				vac_present:1;
+	u16				vac_current;	/* [mA] */
+	unsigned long			event;
+	int				mA;
+	bool				dcd_online;	/* DCD status */
+};
+
+static inline int twl5031_bcc_read(u8 reg)
+{
+	int ret;
+	u8 val;
+
+	ret = twl_i2c_read_u8(TWL5031_MODULE_BCC, &val, reg);
+	if (ret)
+		return ret;
+
+	return val;
+}
+
+static inline int twl5031_bcc_write(u8 reg, u8 val)
+{
+	return twl_i2c_write_u8(TWL5031_MODULE_BCC, val, reg);
+}
+
+static inline int twl5031_usb_read(u8 reg)
+{
+	int ret;
+	u8 val;
+
+	ret = twl_i2c_read_u8(TWL_MODULE_USB, &val, reg);
+	if (ret)
+		return ret;
+
+	return val;
+}
+
+static inline int twl5031_usb_write(u8 reg, u8 val)
+{
+	return twl_i2c_write_u8(TWL_MODULE_USB, val, reg);
+}
+
+static inline void
+twl5031_bcc_vac_update_present(struct twl5031_bcc_data *bcc, int val)
+{
+	if (bcc->vac_present != val) {
+		bcc->vac_present = !!val;
+		power_supply_changed(bcc->vac);
+	}
+}
+
+static int twl5031_bcc_usb_charger_type(struct twl5031_bcc_data *bcc)
+{
+	enum power_supply_type type = POWER_SUPPLY_TYPE_USB;
+
+	u8 reg;
+	u8 func_ctrl, otg_ctrl;
+
+	/* The transceiver must be resumed before this operation */
+	usb_phy_set_suspend(bcc->otg, 0);
+
+	func_ctrl = twl5031_usb_read(ULPI_FUNC_CTRL);
+	otg_ctrl = twl5031_usb_read(ULPI_OTG_CTRL);
+
+	/* disable pulldowns */
+	reg = ULPI_OTG_CTRL_DM_PULLDOWN | ULPI_OTG_CTRL_DP_PULLDOWN;
+	twl5031_usb_write(ULPI_CLR(ULPI_OTG_CTRL), reg);
+
+	/* full speed */
+	twl5031_usb_write(ULPI_CLR(ULPI_FUNC_CTRL),
+			ULPI_FUNC_CTRL_XCVRSEL_MASK);
+	twl5031_usb_write(ULPI_SET(ULPI_FUNC_CTRL), ULPI_FUNC_CTRL_FULL_SPEED);
+
+	/* enable DP pullup */
+	twl5031_usb_write(ULPI_SET(ULPI_FUNC_CTRL), ULPI_FUNC_CTRL_TERMSELECT);
+	udelay(100);
+
+	reg = twl5031_usb_read(ULPI_DEBUG);
+
+	twl5031_usb_write(ULPI_FUNC_CTRL, func_ctrl);
+	twl5031_usb_write(ULPI_OTG_CTRL, otg_ctrl);
+
+	if ((reg & 3) != 3) {
+		type = POWER_SUPPLY_TYPE_USB_CDP;
+	} else {
+		type = POWER_SUPPLY_TYPE_USB_DCP;
+		usb_phy_set_suspend(bcc->otg, 1);
+	}
+
+	return type;
+}
+
+/**
+ * Trigger software driven data contact detection (DCD) to enable more
+ * robust dedicated charging port (DCP) detection
+ */
+static inline bool twl5031_bcc_psy_dcd_detect(struct twl5031_bcc_data *bcc)
+{
+	unsigned long timeout;
+	int res;
+	bool online = false;
+
+	res = twl5031_bcc_read(TWL5031_USB_CHRG_CTRL1);
+	if (res < 0)
+		goto out;
+
+	/* DCD init: enable DP source and DM pulldown */
+	res |= (TWL5031_USB_SW_CTRL_EN |
+		TWL5031_CHGD_IDX_SRC_EN_LOWV |
+		TWL5031_CHGD_SERX_EN_LOWV);
+	if (twl5031_bcc_write(TWL5031_USB_CHRG_CTRL1, res) < 0)
+		goto out;
+
+	/* DCD check: wait for DP line to be low
+	 *
+	 * twl5031 specification claims for typical value of 2.72 sec.
+	 * Make it a bit worse by rounding to 3 sec.
+	 */
+	timeout = jiffies + msecs_to_jiffies(3000);
+	do {
+		/* read comparator output */
+		res = twl5031_bcc_read(TWL5031_USB_CHRG_CTRL1);
+		if (res < 0)
+			goto out;
+
+		if (!(res & TWL5031_CHGD_SERX_DP_LOWV)) {
+			printk(KERN_ERR "DCD succeeded\n");
+			online = true;
+			break;
+		}
+
+		cpu_relax();
+	} while (!time_after(jiffies, timeout));
+
+	res = twl5031_bcc_read(TWL5031_USB_CHRG_CTRL1);
+	if (res < 0)
+		goto out;
+
+	/* DCD de-init: disable DP source and DM pulldown */
+	res &= ~(TWL5031_USB_SW_CTRL_EN |
+		TWL5031_CHGD_IDX_SRC_EN_LOWV |
+		TWL5031_CHGD_SERX_EN_LOWV);
+	twl5031_bcc_write(TWL5031_USB_CHRG_CTRL1, res);
+out:
+	bcc->dcd_online = online;
+
+	return online;
+}
+
+/** Trigger hardware controlled FSM to detect dedicated USB charger */
+static void twl5031_bcc_psy_fsm_detect(struct twl5031_bcc_data *bcc)
+{
+	unsigned long timeout;
+	int res = 0;
+	enum power_supply_type psy_type = POWER_SUPPLY_TYPE_UNKNOWN;
+	int ctl;
+
+	/* this particular regulator is required for DCD */
+	res = regulator_enable(bcc->usb3v1);
+	if (res < 0)
+		return;
+
+	/** perform DCD to secure following charger detection */
+	if (!twl5031_bcc_psy_dcd_detect(bcc)) {
+		dev_notice(bcc->dev, "dcd failed\n");
+		/* ignore error and force charger detection */
+	}
+
+	/* Let USB dedicated FSM to control current sources */
+	res = twl5031_bcc_read(TWL5031_USB_CHRG_CTRL1);
+	if (res < 0)
+		goto out;
+
+	res &= ~TWL5031_USB_SW_CTRL_EN;
+	res = twl5031_bcc_write(TWL5031_USB_CHRG_CTRL1, res);
+	if (res < 0)
+		goto out;
+
+	/* Enable USB FSM (STM mode) */
+	ctl = twl5031_bcc_read(TWL5031_BCC_CTRL2);
+	if (ctl < 0)
+		goto out;
+
+	ctl |= (TWL5031_CHGMODE_SW | TWL5031_SW_USB_DET_EN);
+	if (twl5031_bcc_write(TWL5031_BCC_CTRL2, ctl) < 0)
+		goto out;
+
+	/* Read status */
+	timeout = jiffies + msecs_to_jiffies(500);
+	do {
+		res = twl5031_bcc_read(TWL5031_BCC_STS);
+		if (res == 0xaa) /* no VBUS, no charger, BCC in reset state */
+			continue;
+		if (res < 0)
+			continue;
+
+		if (!(res & TWL5031_BATTERY_PRESENCE_STS)) {
+			dev_err(bcc->dev, "no battery present\n");
+			continue;
+		}
+
+		/* USB charger and battery presence bits should be high */
+		if (!(res & TWL5031_USB_P_STS)) {
+			printk(KERN_ERR "no usb charger present\n");
+			continue;
+		}
+
+		res &= TWL5031_USB_DET_STS_MASK;
+		if (res == TWL5031_USB_DET_STS_500MA)
+			break;
+
+	} while (!time_after(jiffies, timeout) && bcc->dcd_online);
+
+	switch (res) {
+	case TWL5031_USB_DET_STS_500MA:
+		ctl |= TWL5031_SW_CHRG_DET | TWL5031_SW_USBCHRG_EN;
+		bcc->usb_present = true;
+		bcc->usb_current = 500;
+		psy_type = twl5031_bcc_usb_charger_type(bcc);
+		dev_dbg(bcc->dev, "500mA detected, STS %02x\n", res);
+		break;
+	case TWL5031_USB_DET_STS_100MA:
+		ctl |= TWL5031_SW_USBCHRG_EN;
+		psy_type = POWER_SUPPLY_TYPE_USB;
+		bcc->usb_present = true;
+		bcc->usb_current = 100;
+		dev_dbg(bcc->dev, "100mA detected, STS %02x\n", res);
+		break;
+	default:
+		ctl &= ~TWL5031_SW_USBCHRG_EN;
+		dev_dbg(bcc->dev, "No charger detected, STS %02x\n", res);
+		break;
+	}
+
+	if (psy_type != POWER_SUPPLY_TYPE_UNKNOWN) {
+		bcc->usb_desc.type = psy_type;
+		power_supply_changed(bcc->usb);
+	}
+
+	ctl &= ~TWL5031_SW_USB_DET_EN; /* save result, stop FSM */
+	if (twl5031_bcc_write(TWL5031_BCC_CTRL2, ctl) < 0)
+		goto out;
+
+out:
+	regulator_disable(bcc->usb3v1);
+}
+
+static void twl5031_bcc_psy_usb_detect(struct twl5031_bcc_data *bcc)
+{
+	/* disable all regulators + put the transceiver into nondriving mode */
+	usb_phy_set_suspend(bcc->otg, 1);
+
+	twl5031_bcc_psy_fsm_detect(bcc); /* detect charger */
+
+	/* verify dedicated charger */
+	if (bcc->dcd_online) {
+		switch (bcc->usb_desc.type) {
+		case POWER_SUPPLY_TYPE_USB:
+			dev_dbg(bcc->dev, "Standard Downstream Port\n");
+			break;
+		case POWER_SUPPLY_TYPE_USB_CDP:
+			dev_dbg(bcc->dev, "Charging Downstream Port\n");
+			break;
+		case POWER_SUPPLY_TYPE_USB_ACA:
+			dev_dbg(bcc->dev, "Accessory Charger Adapter\n");
+			break;
+		case POWER_SUPPLY_TYPE_USB_DCP:	/* Dedicated charger */
+			dev_dbg(bcc->dev, "Dedicated Charging Port\n");
+			break;
+		default:
+			dev_dbg(bcc->dev, "UNKOWN port type, trying to connect\n");
+		}
+	}
+}
+
+static void twl5031_bcc_event_work(struct work_struct *work)
+{
+	struct twl5031_bcc_data	*bcc;
+	unsigned long event;
+	int mA;
+
+	bcc = container_of(work, struct twl5031_bcc_data, work);
+
+	mutex_lock(&bcc->mutex);
+
+	event = bcc->event;
+	mA = bcc->mA;
+
+	switch (event) {
+	case USB_EVENT_NONE:
+		bcc->usb_present = 0;
+		bcc->usb_current = 0;
+		bcc->dcd_online = false;
+		bcc->usb_desc.type = POWER_SUPPLY_TYPE_USB;
+		break;
+	case USB_EVENT_VBUS:
+		twl5031_bcc_psy_usb_detect(bcc);
+		break;
+	case USB_EVENT_ENUMERATED:
+		if (mA <= 0)
+			return;
+
+		bcc->usb_present = 1;
+
+		switch (bcc->usb_desc.type) {
+		case POWER_SUPPLY_TYPE_USB_CDP:
+			/*
+			 * Theoretical maximum, this should
+			 * indicate BME to increase input
+			 * current in small steps until
+			 * real maximum is achieved
+			 */
+			bcc->usb_current = 900;
+			break;
+		case POWER_SUPPLY_TYPE_USB: /* FALLTHROUGH */
+		default:
+			bcc->usb_current = mA;
+			break;
+		}
+		break;
+	default:
+		dev_dbg(bcc->dev, "unsupported event %lu\n", event);
+	}
+
+	power_supply_changed(bcc->usb);
+	mutex_unlock(&bcc->mutex);
+}
+
+/* atomic notifier support */
+static int bcc_notifier_call(struct notifier_block *nb,
+		unsigned long event, void *power)
+{
+	struct twl5031_bcc_data	*bcc;
+
+	bcc = container_of(nb, struct twl5031_bcc_data, nb);
+	bcc->event = event;
+
+	dev_dbg(bcc->dev, "received event=%lu\n", event);
+
+	if (power)
+		bcc->mA = *((int *) power);
+
+	queue_work(bcc->wq, &bcc->work);
+
+	return NOTIFY_OK;
+}
+
+/*
+ * Updates charger presense information immediately. This function
+ * should not be called on the spot when status change interrupt
+ * occurs, as the status bit in hardware will be updated after
+ * a delay.
+ */
+static void twl5031_bcc_psy_vac_detect(struct twl5031_bcc_data *bcc)
+{
+	int val;
+
+	val = twl5031_bcc_read(TWL5031_BCC_STS);
+	if (val < 0 || val == 0xaa) {
+		/* reading failed or charger is not present */
+		twl5031_bcc_vac_update_present(bcc, 0);
+	} else {
+		val = (val & TWL5031_VAC_P_STS) ? 1 : 0;
+		twl5031_bcc_vac_update_present(bcc, val);
+	}
+}
+
+static irqreturn_t twl5031_bcc_pm_irq_thread(int irq, void *_bcc)
+{
+	struct twl5031_bcc_data *bcc = _bcc;
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout((HZ / 10) + 1);
+	twl5031_bcc_psy_vac_detect(bcc);
+
+	return IRQ_HANDLED;
+}
+
+static int twl5031_bcc_get_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct twl5031_bcc_data *bcc = dev_get_drvdata(psy->dev.parent);
+	int ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = (psy->desc->type == POWER_SUPPLY_TYPE_MAINS) ?
+			bcc->vac_present : bcc->usb_present;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = (psy->desc->type == POWER_SUPPLY_TYPE_MAINS) ?
+			bcc->vac_current : bcc->usb_current;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static enum power_supply_property twl5031_charger_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static int twl5031_bcc_probe(struct platform_device *pdev)
+{
+	struct twl5031_bcc_data *bcc;
+	int ret = -ENODEV;
+
+	bcc = devm_kzalloc(&pdev->dev, sizeof(*bcc), GFP_KERNEL);
+	if (!bcc)
+		return -ENOMEM;
+
+	bcc->dev = &pdev->dev;
+	platform_set_drvdata(pdev, bcc);
+
+	bcc->usb3v1 = devm_regulator_get(&pdev->dev, "bci3v1");
+	if (IS_ERR(bcc->usb3v1))
+		return ret;
+
+	bcc->vac_desc.name = "twl5031_vac",
+	bcc->vac_desc.type = POWER_SUPPLY_TYPE_MAINS,
+	bcc->vac_desc.properties = twl5031_charger_props,
+	bcc->vac_desc.num_properties = ARRAY_SIZE(twl5031_charger_props),
+	bcc->vac_desc.get_property = twl5031_bcc_get_property,
+	bcc->vac = devm_power_supply_register(&pdev->dev, &bcc->vac_desc,
+					     NULL);
+	if (IS_ERR(bcc->vac)) {
+		ret = PTR_ERR(bcc->vac);
+		dev_err(&pdev->dev, "failed to register vac: %d\n", ret);
+		return ret;
+	}
+
+	bcc->usb_desc.name = "twl5031_usb",
+	bcc->usb_desc.type = POWER_SUPPLY_TYPE_USB,
+	bcc->usb_desc.properties = twl5031_charger_props,
+	bcc->usb_desc.num_properties = ARRAY_SIZE(twl5031_charger_props),
+	bcc->usb_desc.get_property = twl5031_bcc_get_property,
+	bcc->usb = devm_power_supply_register(&pdev->dev, &bcc->usb_desc,
+					      NULL);
+	if (IS_ERR(bcc->usb)) {
+		ret = PTR_ERR(bcc->usb);
+		dev_err(&pdev->dev, "failed to register usb: %d\n", ret);
+		return ret;
+	}
+
+	twl5031_bcc_psy_vac_detect(bcc);	/* probe vac charger */
+
+	/* request charger detection interrupt */
+	ret = devm_request_threaded_irq(&pdev->dev, platform_get_irq(pdev, 0), NULL,
+				   twl5031_bcc_pm_irq_thread,
+				   IRQF_ONESHOT, "twl5031_chgdet", bcc);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "could not request irq (chg det), status %d\n", ret);
+		return ret;
+	}
+
+	INIT_WORK(&bcc->work, twl5031_bcc_event_work);
+	mutex_init(&bcc->mutex);
+
+	bcc->nb.notifier_call = bcc_notifier_call;
+	if (bcc->dev->of_node) {
+		struct device_node *phynode;
+
+		phynode = of_find_compatible_node(bcc->dev->of_node->parent,
+						  NULL, "ti,twl4030-usb");
+		if (phynode)
+			bcc->otg = devm_usb_get_phy_by_node(
+				bcc->dev, phynode, &bcc->nb);
+	}
+
+	if (!bcc->otg) {
+		dev_err(&pdev->dev, "could not find twl4030-usb phy\n");
+		return ret;
+	}
+
+	bcc->wq = create_singlethread_workqueue("bcc");
+	if (!bcc->wq)
+		return -ENOMEM;
+
+	twl5031_bcc_write(TWL5031_LED_DRIVER_CTRL, TWL5031_LEDC_DISABLE);
+
+	return 0;
+}
+
+static int __exit twl5031_bcc_remove(struct platform_device *pdev)
+{
+	struct twl5031_bcc_data *bcc = platform_get_drvdata(pdev);
+
+	destroy_workqueue(bcc->wq);
+
+	return 0;
+}
+
+static const struct of_device_id twl_bcc_of_match[] = {
+	{.compatible = "ti,twl5031-bcc", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, twl_bcc_of_match);
+
+static struct platform_driver twl5031_bcc_driver = {
+	.probe = twl5031_bcc_probe,
+	.driver	= {
+		.name	= "twl5031-bcc",
+		.of_match_table = of_match_ptr(twl_bcc_of_match),
+	},
+	.remove	= __exit_p(twl5031_bcc_remove),
+};
+module_platform_driver(twl5031_bcc_driver);
+
+MODULE_AUTHOR("Nokia Corporation");
+MODULE_DESCRIPTION("TWL5031 Battery Charger Control driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:twl5031_bcc");
diff --git a/include/linux/i2c/twl.h b/include/linux/i2c/twl.h
index 9ad7828d9d34..6547d302c3b8 100644
--- a/include/linux/i2c/twl.h
+++ b/include/linux/i2c/twl.h
@@ -70,6 +70,7 @@ enum twl4030_module_ids {
	TWL4030_MODULE_INT,

	TWL5031_MODULE_ACCESSORY,
+	TWL5031_MODULE_BCC,
	TWL5031_MODULE_INTERRUPTS,

	TWL4030_MODULE_LAST,
--
2.11.0
