From 2b9602d97dced4cb64b035b5ff1de7d82fa4ad22 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Filip=20Matijevi=C4=87?= <filip.matijevic.pz@gmail.com>
Date: Sun, 14 Feb 2016 19:58:28 +0100
Subject: [PATCH 21/53] input/mfd: Add support for TWL5031 ACI & Nokia ECI
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Filip MatijeviÄ‡ <filip.matijevic.pz@gmail.com>
---
 drivers/input/misc/Kconfig      |   14 +
 drivers/input/misc/Makefile     |    1 +
 drivers/input/misc/eci.c        |  826 ++++++++++++++++
 drivers/mfd/Kconfig             |   17 +
 drivers/mfd/Makefile            |    1 +
 drivers/mfd/twl-core.c          |    8 +
 drivers/mfd/twl5031-aci.c       | 2080 +++++++++++++++++++++++++++++++++++++++
 include/linux/i2c/twl.h         |   11 +
 include/linux/input/eci.h       |   96 ++
 include/linux/mfd/twl5031-aci.h |  149 +++
 include/sound/n9.h              |   21 +
 sound/soc/omap/n9.c             |   24 +-
 12 files changed, 3247 insertions(+), 1 deletion(-)
 create mode 100644 drivers/input/misc/eci.c
 create mode 100644 drivers/mfd/twl5031-aci.c
 create mode 100644 include/linux/input/eci.h
 create mode 100644 include/linux/mfd/twl5031-aci.h
 create mode 100644 include/sound/n9.h

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 1ba6fd96bab4..4dbfaac3045e 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -840,4 +840,18 @@ config INPUT_VIBRA_SPI
	  To compile this driver as a module, choose M here: the
	  module will be called vibra_spi.

+config INPUT_ECI
+	tristate "AV ECI (Enhancement Control Interface) Driver"
+	help
+	  The Enhancement Control Interface functionality
+	  ECI is smart headset for phones with many buttons
+
+	  ECI provides the following features:
+	  - ECI configuration memory
+	  - ECI buttons handling
+
+	  Say 'y' here to statically link this module into the kernel or 'm'
+	  to build it as a dynamically loadable module. The module will be
+	  called eci.ko
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 56c272afa1eb..03189baff4a6 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -79,3 +79,4 @@ obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+obj-$(CONFIG_INPUT_ECI)		+= eci.o
diff --git a/drivers/input/misc/eci.c b/drivers/input/misc/eci.c
new file mode 100644
index 000000000000..1ff717c63814
--- /dev/null
+++ b/drivers/input/misc/eci.c
@@ -0,0 +1,826 @@
+/*
+ * This file is combines HW independent part of AV ECI (Enhancement Control
+ * Interface) and ACI (Accessory Control Interface) drivers
+ *
+ * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * Contact: Tapio Vihuri <tapio.vihuri@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include <linux/mfd/twl5031-aci.h>
+#include <sound/n9.h>
+#include <linux/input.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <sound/jack.h>
+#include <linux/input/eci.h>
+#include <linux/slab.h>
+
+#define ECI_DRIVERNAME	"ECI_accessory"
+
+#define ECI_WAIT_SEND_BUTTON		5	/* ms */
+#define ECI_WAIT_BUS_SETTLE_LO		20000	/* us */
+#define ECI_WAIT_BUS_SETTLE_HI		20100	/* us */
+#define ECI_TRY_GET_MEMORY			2000	/* ms */
+#define ECI_TRY_INIT_IO				200	/* ms */
+#define ECI_TRY_SET_MIC				200	/* ms */
+#define ECI_KEY_REPEAT_INTERVAL		400	/* ms */
+
+#define ECI_EKEY_BLOCK_ID					0xb3
+#define ECI_ENHANCEMENT_FEATURE_BLOCK_ID	0x02
+
+/* ECI Inputs */
+#define ECI_NIL_FEATURE					0x00 /* No feature */
+#define ECI_IGNS						0x01 /* Ignition Sense */
+#define ECI_CK_HANDSET_HOOK				0x02 /* Car-Kit Handset Hook */
+#define ECI_POWER_SUPPLY				0x03 /* Power Supply/Car Battery Det  */
+#define ECI_EXT_AUD_IN					0x06 /* External audio In */
+#define ECI_SEND_END_VR					0x07 /* Send, End, and Voice Recogn */
+#define ECI_HD_PLUG						0x08 /* Headphone plug */
+#define ECI_DEV_POWER_REQ				0x0a /* Device Power Request */
+#define ECI_VOL_UP						0x0b /* Volume Up */
+#define ECI_VOL_DOWN					0x0c /* Volume Down */
+#define ECI_PLAY_PAUSE_CTRL				0x0d /* Play / Pause */
+#define ECI_STOP						0x0e /* Stop */
+#define ECI_NEXT_FF_AUTOSRC_UP			0x0f /* Next/Fast Fward/Autosearch up */
+#define ECI_PREV_REW_AUTOSEARCH_DOWN	0x10 /* Prev/Rewind/Autosearch down */
+#define ECI_POC							0x11 /* Push to Talk over Cellular */
+#define ECI_SYNC_BTN					0x14 /* Synchronization Button */
+#define ECI_MUSIC_RADIO_OFF_SELECTOR	0x15 /* Music/Radio/Off Selector */
+#define ECI_REDIAL						0x16 /* Redial */
+#define ECI_LEFT_SOFT_KEY				0x17 /* Left Soft Key */
+#define ECI_RIGHT_SOFT_KEY				0x18 /* Right Soft key */
+#define ECI_SEND_KEY					0x19 /* Send key */
+#define ECI_END_KEY						0x1a /* End key */
+#define ECI_MIDDLE_SOFT_KEY				0x1b /* Middle Soft key */
+#define ECI_UP							0x1c /* UP key/joystick direction */
+#define ECI_DOWN						0x1d /* DOWN key/joystick direction */
+#define ECI_RIGHT						0x1e /* RIGHT key/joystick direction */
+#define ECI_LEFT						0x1f /* LEFT key/joystick direction */
+#define ECI_SYMBIAN_NAVY_KEY			0x20 /* Symbian Application key */
+#define ECI_TERMINAL_APP_CTRL_IN		0x21 /* Terminal Applicat Ctrl Input */
+#define ECI_USB_CLASS_SWITCHING			0x23 /* USB Class Switching */
+#define ECI_MUTE						0x24 /* Mute */
+/* ECI Outputs */
+#define ECI_CRM						0x82 /* Car Radio Mute */
+#define ECI_PWR						0x83 /* Power */
+#define ECI_AUD_AMP					0x85 /* Audio Amplifier */
+#define ECI_EXT_AUD_SWITCH			0x86 /* External Audio Switch */
+#define ECI_HANDSET_AUDIO			0x87 /* Handset Audio */
+#define ECI_RING_INDICATOR			0x88 /* Ringing Indicator */
+#define ECI_CALL_ACTIVE				0x89 /* Call Active */
+#define ECI_ENHANCEMENT_DETECTED	0x8b /* Enhancement Detected */
+#define ECI_AUDIO_BLOCK_IN_USE		0x8e /* Audio Block In Use */
+#define ECI_STEREO_AUDIO_ACTIVE		0x8f /* stereo audio used in terminal */
+#define ECI_MONO_AUDIO_ACTIVE		0x90 /* mono audio used in terminal */
+#define ECI_TERMINAL_APP_CTRL_OUT	0x91 /* Terminal Applicat Ctrl Output */
+
+/*
+ * Most of these are switch codes that are put on top of keys (KEY_MAX ->).
+ */
+static int eci_codes[] = {
+	KEY_UNKNOWN,					/* 0  ECI_NIL_FEATURE */
+	KEY_UNKNOWN,					/* 1  ECI_IGNS */
+	KEY_UNKNOWN,					/* 2  ECI_CK_HANDSET_HOOK */
+	KEY_BATTERY,					/* 3  ECI_POWER_SUPPLY */
+	KEY_RESERVED,					/* 4  ECI feature not defined */
+	KEY_RESERVED,					/* 5  ECI feature not defined */
+	KEY_AUDIO,						/* 6  ECI_EXT_AUD_IN */
+	KEY_PHONE,						/* 7  ECI_SEND_END_VR */
+	KEY_MAX + SW_HEADPHONE_INSERT,	/* 8  ECI_HD_PLUG, type switch */
+	KEY_RESERVED,					/* 9  ECI feature not defined */
+	KEY_UNKNOWN,					/* 10 ECI_DEV_POWER_REQ */
+	KEY_VOLUMEUP,					/* 11 ECI_VOL_UP */
+	KEY_VOLUMEDOWN,					/* 12 ECI_VOL_DOWN */
+	KEY_PLAYPAUSE,					/* 13 ECI_PLAY_PAUSE_CTRL */
+	KEY_STOP,						/* 14 ECI_STOP */
+	KEY_FORWARD,					/* 15 ECI_NEXT_FF_AUTOSRC_UP */
+	KEY_REWIND,						/* 16 ECI_PREV_REW_AUTOSEARCH_DOWN */
+	KEY_UNKNOWN,					/* 17 ECI_POC */
+	KEY_RESERVED,					/* 18 ECI feature not defined */
+	KEY_RESERVED,					/* 19 ECI feature not defined */
+	KEY_UNKNOWN,					/* 20 ECI_SYNC_BTN */
+	KEY_RADIO,						/* 21 ECI_MUSIC_RADIO_OFF_SELECTOR */
+	KEY_UNKNOWN,					/* 22 ECI_REDIAL */
+	KEY_UNKNOWN,					/* 23 ECI_LEFT_SOFT_KEY */
+	KEY_UNKNOWN,					/* 24 ECI_RIGHT_SOFT_KEY */
+	KEY_SEND,						/* 25 ECI_SEND_KEY */
+	KEY_END,						/* 26 ECI_END_KEY */
+	KEY_UNKNOWN,					/* 27 ECI_MIDDLE_SOFT_KEY */
+	KEY_UP,							/* 28 ECI_UP */
+	KEY_DOWN,						/* 29 ECI_DOWN */
+	KEY_RIGHT,						/* 30 ECI_RIGHT */
+	KEY_LEFT,						/* 31 ECI_LEFT */
+	KEY_UNKNOWN,					/* 32 ECI_SYMBIAN_NAVY_KEY */
+	KEY_UNKNOWN,					/* 33 ECI_TERMINAL_APP_CTRL_IN */
+	KEY_RESERVED,					/* 34 ECI feature not defined */
+	KEY_UNKNOWN,					/* 35 ECI_USB_CLASS_SWITCHING */
+	KEY_MUTE,						/* 36 ECI_MUTE */
+};
+
+static struct aci_cb aci_callback;
+static struct eci_cb eci_callback;
+static struct dfl61audio_hsmic_event hsmic_event;
+
+static struct eci_data *the_eci;
+
+/* Returns size of accessory memory or error. */
+static int eci_get_ekey(struct eci_data *eci, int *key)
+{
+	u8 buf[4];
+	struct block {
+		u8 id;
+		u8 len;
+		u16 size;
+	} *ekey = (void *)buf;
+	int ret;
+
+	/* Read always four bytes. */
+	ret = eci->eci_hw_ops->acc_read_direct(0, buf);
+	if (ret)
+		return ret;
+
+	if (ekey->id != ECI_EKEY_BLOCK_ID)
+		return -ENODEV;
+
+	*key = be16_to_cpu(ekey->size);
+
+	return 0;
+}
+
+static ssize_t show_eci_memory(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (!the_eci->mem_ok)
+		return -ENXIO;
+
+	memcpy(buf, the_eci->memory, the_eci->mem_size);
+
+	return the_eci->mem_size;
+}
+
+static DEVICE_ATTR(memory, S_IRUGO, show_eci_memory, NULL);
+
+static struct attribute *eci_attributes[] = {
+	&dev_attr_memory.attr,
+	NULL
+};
+
+static struct attribute_group eci_attr_group = {
+	.attrs = eci_attributes
+};
+
+/* Read ECI device memory into buffer. */
+static int eci_get_memory(struct eci_data *eci, int *restart)
+{
+	int i, ret;
+
+	for (i = *restart; i < eci->mem_size; i += 4) {
+		ret = eci->eci_hw_ops->acc_read_direct(i, eci->memory + i);
+		*restart = i;
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+/*
+ * This should be really init_features, but most often these are just buttons.
+ */
+static int eci_init_buttons(struct eci_data *eci)
+{
+	struct enhancement_features_fixed *eff = eci->e_features_fix;
+	u8 n, mireg;
+	int ret;
+	u8 buf[4];
+
+	n = eff->number_of_features;
+
+	if (n > ECI_MAX_FEATURE_COUNT)
+		return -EINVAL;
+
+	ret = eci->eci_hw_ops->acc_read_reg(ECICMD_MASTER_INT_REG, buf, 1);
+	if (ret)
+		return ret;
+
+	mireg = buf[0];
+	mireg &= ~ECI_INT_ENABLE;
+	mireg |= ECI_INT_LEN_120US | ECI_INT_DELAY_ENABLE;
+
+	ret = eci->eci_hw_ops->acc_write_reg(ECICMD_MASTER_INT_REG, mireg);
+	if (ret) {
+		dev_err(eci->dev, "Unable to set accessory interrupts\n");
+		return ret;
+	}
+
+	usleep_range(ECI_WAIT_BUS_SETTLE_LO, ECI_WAIT_BUS_SETTLE_HI);
+	mireg |= ECI_INT_ENABLE;
+	ret = eci->eci_hw_ops->acc_write_reg(ECICMD_MASTER_INT_REG, mireg);
+	if (ret) {
+		dev_err(eci->dev, "Unable to set accessory interrupts\n");
+		return ret;
+	}
+
+	usleep_range(ECI_WAIT_BUS_SETTLE_LO, ECI_WAIT_BUS_SETTLE_HI);
+
+	return ret;
+}
+
+/* Find "enhancement features" block from buffer. */
+static int eci_get_enhancement_features(struct eci_data *eci)
+{
+	u8 *mem = (void *)eci->memory;
+	struct block {
+		u8 id;
+		u8 len;
+	} *b = (void *)mem;
+	struct block *mem_end = (void *)(eci->memory + eci->mem_size);
+
+	if (b->id != ECI_EKEY_BLOCK_ID)
+		return -ENODEV;
+
+	do {
+		dev_vdbg(eci->dev, "skip BLOCK 0x%02x, LEN 0x%02x\n",
+				b->id, b->len);
+		if (!b->len)
+			return -EINVAL;
+
+		mem += b->len;
+		b = (void *)mem;
+		eci->e_features_fix = (void *)b;
+		dev_vdbg(eci->dev, "found BLOCK 0x%02x, LEN 0x%02x\n",
+				b->id, b->len);
+		if (b->id == ECI_ENHANCEMENT_FEATURE_BLOCK_ID)
+			return 0;
+	} while (b < mem_end);
+
+	return -ENFILE;
+}
+
+/*
+ * Find out ECI features:
+ * All ECI memory block parsing is done here, be careful as pointers to memory
+ * tend to go wrong easily. ECI "Enhancement Features" block is variable size,
+ * so we try to catch out of block pointers due memory reading errors etc.
+ *
+ * I/O support field is not implemented, data direction field is not
+ * implemented, nor writing to the ECI I/O.
+ */
+static int eci_parse_enhancement_features(struct eci_data *eci)
+{
+	struct enhancement_features_fixed *eff = eci->e_features_fix;
+	struct enhancement_features_variable *efv = &eci->e_features_var;
+	int i;
+	u8 n, k;
+	void *mem_end = (void *)((u8 *)eff + eff->length);
+
+	dev_vdbg(eci->dev, "block id 0x%02x length 0x%02x connector "
+			"configuration 0x%02x\n", eff->block_id, eff->length,
+			eff->connector_conf);
+	n = eff->number_of_features;
+	dev_vdbg(eci->dev, "number of features %d\n", n);
+
+	if (n > ECI_MAX_FEATURE_COUNT)
+		return -EINVAL;
+
+	k = DIV_ROUND_UP(n, 8);
+	dev_vdbg(eci->dev, "I/O support bytes count %d\n", k);
+
+	efv->io_support = &eff->number_of_features + 1;
+	/* efv->io_functionality[0] is not used! pins are in 1..31 range */
+	efv->io_functionality = efv->io_support + k - 1;
+	efv->active_state = efv->io_functionality + n + 1;
+
+	if ((void *)&efv->active_state[k] > mem_end)
+		return -EINVAL;
+
+	/* last part of block */
+	for (i = 0; i < k; i++)
+		dev_vdbg(eci->dev, "active_state[%d] 0x%02x\n", i,
+				efv->active_state[i]);
+
+	eci->buttons_data.buttons_up_mask = ~be32_to_cpu(
+			(*(u32 *)efv->active_state)) & (BIT_MASK(n + 1) - 1);
+	dev_dbg(eci->dev, "buttons mask 0x%08x\n",
+			eci->buttons_data.buttons_up_mask);
+	/*
+	 * ECI accessory responses use as many bytes needed for I/O pins
+	 * up to four bytes, when lines 24..31 are used. All tested ECI
+	 * accessories, however, return two data bytes event though there
+	 * are less than eight I/O pins.
+	 *
+	 * So we get always a reading error if there are less than eight I/Os.
+	 * Meanwhile just use this kludge, FIXME.
+	 */
+	k = DIV_ROUND_UP(n + 1, 8);
+	if (k == 1)
+		k = 2;
+	eci->port_reg_count = k;
+
+	return 0;
+}
+
+static int eci_init_accessory(struct eci_data *eci)
+{
+	int ret, key = 0, restart = 0;
+	unsigned long future;
+
+	eci->mem_ok = false;
+	usleep_range(ECI_WAIT_BUS_SETTLE_LO, ECI_WAIT_BUS_SETTLE_HI);
+
+	ret = eci->eci_hw_ops->acc_reset();
+	if (ret) {
+		dev_err(eci->dev, "Acc_reset fails\n");
+		return ret;
+	}
+
+	usleep_range(ECI_WAIT_BUS_SETTLE_LO, ECI_WAIT_BUS_SETTLE_HI);
+
+	ret = eci->eci_hw_ops->acc_write_reg(ECICMD_MIC_CTRL, ECI_MIC_OFF);
+	if (ret) {
+		dev_err(eci->dev, "Unable to control headset microphone\n");
+		return ret;
+	}
+
+	/* Get ECI ekey block to determine memory size. */
+	future = jiffies + msecs_to_jiffies(ECI_TRY_GET_MEMORY);
+	do {
+		ret = eci_get_ekey(eci, &key);
+		if (time_is_before_jiffies(future))
+			break;
+	} while (ret);
+
+	if (ret) {
+		dev_err(eci->dev, "Unable to get ekey\n");
+		return ret;
+	}
+
+	eci->mem_size = key;
+	if (eci->mem_size > ECI_MAX_MEM_SIZE) {
+		dev_err(eci->dev, "eci->mem_size too big: %d\n", eci->mem_size);
+		return -EINVAL;
+	}
+
+	/* Get ECI memory. */
+	future = jiffies + msecs_to_jiffies(ECI_TRY_GET_MEMORY);
+	do {
+		ret = eci_get_memory(eci, &restart);
+		if (time_is_before_jiffies(future))
+			break;
+	} while (ret);
+
+	if (ret) {
+		dev_err(eci->dev, "Unable to get memory\n");
+		return ret;
+	}
+
+	if (eci_get_enhancement_features(eci)) {
+		dev_err(eci->dev, "Cannot get enhancement features\n");
+		return -EIO;
+	}
+
+	if (eci_parse_enhancement_features(eci)) {
+		dev_err(eci->dev, "Cannot parse enhancement features\n");
+		return -EIO;
+	}
+
+	/*
+	 * Configure ECI buttons now when we know how after parsing
+	 * enhancement features.
+	 */
+	usleep_range(ECI_WAIT_BUS_SETTLE_LO, ECI_WAIT_BUS_SETTLE_HI);
+	future = jiffies + msecs_to_jiffies(ECI_TRY_INIT_IO);
+	do {
+		ret = eci_init_buttons(eci);
+		if (time_is_before_jiffies(future))
+			break;
+	} while (ret);
+
+	if (ret) {
+		dev_err(eci->dev, "Unable to init buttons\n");
+		return ret;
+	}
+
+	eci->mem_ok = true;
+	usleep_range(ECI_WAIT_BUS_SETTLE_LO, ECI_WAIT_BUS_SETTLE_HI);
+
+	if (eci->eci_hw_ops->acc_write_reg(ECICMD_MIC_CTRL, eci->mic_state))
+		dev_err(eci->dev, "Unable to control headset microphone\n");
+
+	return 0;
+}
+
+static int init_accessory_input(struct eci_data *eci)
+{
+	int err, i, code;
+
+	eci->acc_input = input_allocate_device();
+	if (!eci->acc_input) {
+		dev_err(eci->dev, "Error allocating input device: %d\n",
+				__LINE__);
+		return -ENOMEM;
+	}
+
+	eci->acc_input->name = "ECI Accessory";
+
+	/* Codes on top of KEY_MAX are switch events. */
+	for (i = 0; i < ARRAY_SIZE(eci_codes); i++) {
+		code = eci_codes[i];
+		if (code >= KEY_MAX) {
+			code -= KEY_MAX;
+			set_bit(code, eci->acc_input->swbit);
+		} else {
+			set_bit(code, eci->acc_input->keybit);
+		}
+	}
+
+	set_bit(EV_KEY, eci->acc_input->evbit);
+	set_bit(EV_SW, eci->acc_input->evbit);
+	set_bit(EV_REP, eci->acc_input->evbit);
+
+	err = input_register_device(eci->acc_input);
+	if (err) {
+		dev_err(eci->dev, "Error registering input device: %d\n",
+				__LINE__);
+		goto err_free_dev;
+	}
+
+	/* Must set after input_register_device(). */
+	eci->acc_input->rep[REP_PERIOD] = ECI_KEY_REPEAT_INTERVAL;
+
+	return 0;
+
+err_free_dev:
+	input_free_device(eci->acc_input);
+	return err;
+}
+
+static void remove_accessory_input(struct eci_data *eci)
+{
+	input_unregister_device(eci->acc_input);
+}
+
+/* Press/release button */
+static int eci_get_button(struct eci_data *eci)
+{
+	struct eci_buttons_data *b = &eci->buttons_data;
+
+	if (b->windex < ECI_BUTTON_BUF_SIZE) {
+		if (b->buttons_buf[b->windex] == 0)
+			b->buttons_buf[b->windex] = b->buttons;
+		else
+			dev_err(eci->dev, "ECI button queue owerflow %d\n",
+			       __LINE__);
+	}
+	b->windex++;
+	if (b->windex == ECI_BUTTON_BUF_SIZE)
+		b->windex = 0;
+
+	return 0;
+}
+
+/* Intended to be used ONLY inside eci_parse_button() ! */
+#define ACTIVE_STATE(x) (be32_to_cpu(*(u32 *)efv->active_state) & BIT(x-1))
+#define BUTTON_STATE(x) ((buttons & BIT(x))>>1)
+
+static void eci_parse_button(struct eci_data *eci, u32 buttons)
+{
+	int pin, code, state = 0;
+	u8 n, io_fun;
+	struct enhancement_features_variable *efv = &eci->e_features_var;
+	struct enhancement_features_fixed *eff = eci->e_features_fix;
+
+	n = eff->number_of_features;
+
+	for (pin = 1; pin <= n; pin++)
+		state += (BUTTON_STATE(pin) == ACTIVE_STATE(pin));
+
+	if (state == n) {
+		dev_err(eci->dev, "report all buttons down, reject\n");
+		return;
+	}
+
+	for (pin = 1; pin <= n; pin++) {
+		io_fun = efv->io_functionality[pin] & ~BIT(7);
+		if (io_fun > ECI_MUTE)
+			break;
+		code = eci_codes[io_fun];
+		state = (BUTTON_STATE(pin) == ACTIVE_STATE(pin));
+		if (state)
+			dev_dbg(eci->dev, "I/O functionality 0x%02x "
+					"at pin %d\n", io_fun, pin);
+		if (code >= KEY_MAX)
+			input_report_switch(eci->acc_input, code - KEY_MAX,
+					state);
+		else
+			input_report_key(eci->acc_input, code, state);
+	}
+	input_sync(eci->acc_input);
+}
+
+static int eci_send_button(struct eci_data *eci)
+{
+	int i;
+	struct enhancement_features_fixed *eff = eci->e_features_fix;
+	struct eci_buttons_data *b = &eci->buttons_data;
+	u8 n;
+
+	n = eff->number_of_features;
+
+	if (n > ECI_MAX_FEATURE_COUNT)
+		return -EINVAL;
+	/*
+	 * Codes on top of KEY_MAX are switch events, let the input
+	 * system take care multiple key events.
+	 */
+	for (i = 0; i < ECI_BUTTON_BUF_SIZE; i++) {
+		if (b->buttons_buf[b->rindex] == 0)
+			break;
+
+		eci_parse_button(eci, b->buttons_buf[b->rindex]);
+
+		b->buttons_buf[b->rindex] = 0;
+		b->rindex++;
+		if (b->rindex == ECI_BUTTON_BUF_SIZE)
+			b->rindex = 0;
+	}
+
+	return 0;
+}
+
+static void aci_button_event(bool button_down, void *priv)
+{
+	struct eci_data *eci = priv;
+
+	if (!eci)
+		return;
+
+	if (button_down)
+		input_report_key(eci->acc_input, KEY_PHONE/* BTN_0 */, 1);
+	else
+		input_report_key(eci->acc_input, KEY_PHONE/* BTN_0 */, 0);
+
+	input_sync(eci->acc_input);
+}
+
+/* ACI driver calls this in ECI accessory event. */
+static void eci_accessory_event(int event, void *priv)
+{
+	struct eci_data *eci = priv;
+	struct eci_buttons_data *b = &eci->buttons_data;
+	int delay = 0;
+	int ret = 0;
+
+	eci->event = event;
+	switch (event) {
+	case ECI_EVENT_PLUG_IN:
+		dev_dbg(eci->dev, "ECI_EVENT_PLUG_IN\n");
+		ret = eci_init_accessory(eci);
+		if (ret) {
+			dev_err(eci->dev, "Accessory init %s%s%s%sat: %d\n",
+					ret & ACI_COMMERR ? "COMMERR " : "",
+					ret & ACI_FRAERR ? "FRAERR " : "",
+					ret & ACI_RESERR ? "RESERR " : "",
+					ret & ACI_COLL ? "COLLERR " : "",
+					__LINE__);
+			break;
+		}
+		if (eci->jack_report)
+			eci->jack_report(SND_JACK_HEADSET);
+		dev_dbg(eci->dev, "ECI jack event reported\n");
+		break;
+	case ECI_EVENT_PLUG_OUT:
+		eci->mem_ok = false;
+		break;
+	case ECI_EVENT_BUTTON:
+		dev_dbg(eci->dev, "buttons 0x%08x\n", b->buttons);
+
+		ret = eci_get_button(eci);
+		if (ret)
+			dev_err(eci->dev, "error %d getting buttons\n", ret);
+
+		delay = msecs_to_jiffies(ECI_WAIT_SEND_BUTTON);
+		schedule_delayed_work(&eci->eci_ws, delay);
+		break;
+	default:
+		dev_err(eci->dev, "unknown event %d: %d\n", event, __LINE__);
+		break;
+	}
+
+	return;
+}
+
+static void eci_hsmic_event(void *priv, bool on)
+{
+	struct eci_data *eci = priv;
+	unsigned long future;
+	int ret;
+
+	if (!eci || !eci->mem_ok)
+		return;
+
+	dev_vdbg(eci->dev, "ECI mic %s\n", on ? "auto" : "off");
+
+	if (on)
+		eci->mic_state = ECI_MIC_AUTO;
+	else
+		eci->mic_state = ECI_MIC_OFF;
+
+	future = jiffies + msecs_to_jiffies(ECI_TRY_SET_MIC);
+	do {
+		ret = eci->eci_hw_ops->acc_write_reg(ECICMD_MIC_CTRL,
+				eci->mic_state);
+		if (time_is_before_jiffies(future))
+			break;
+	} while (ret);
+
+	if (ret)
+		dev_err(eci->dev, "Unable to control headset microphone\n");
+}
+
+/* General work function for several tasks. */
+static void eci_work(struct work_struct *ws)
+{
+	struct eci_data *eci = container_of(ws, struct eci_data, eci_ws.work);
+	int ret;
+
+	if (!eci->mem_ok)
+		return;
+
+	ret = eci_send_button(eci);
+	if (ret)
+		dev_err(eci->dev, "Error sending event: %d\n", __LINE__);
+}
+
+static struct miscdevice eci_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = ECI_DRIVERNAME,
+};
+
+struct aci_cb *aci_register(void)
+{
+	if (!the_eci)
+		return ERR_PTR(-EBUSY);
+
+	return &aci_callback;
+}
+EXPORT_SYMBOL(aci_register);
+
+struct eci_cb *eci_register(struct eci_hw_ops *eci_ops)
+{
+	if (!the_eci)
+		return ERR_PTR(-EBUSY);
+
+	if (!eci_ops || !eci_ops->acc_read_direct ||
+			!eci_ops->acc_read_reg || !eci_ops->acc_write_reg ||
+			!eci_ops->acc_reset)
+		return ERR_PTR(-EINVAL);
+
+	the_eci->eci_hw_ops = eci_ops;
+	return &eci_callback;
+}
+EXPORT_SYMBOL(eci_register);
+
+static int eci_probe(struct platform_device *pdev)
+{
+	struct eci_data *eci;
+	struct eci_platform_data *pdata = pdev->dev.platform_data;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	eci = devm_kzalloc(&pdev->dev, sizeof(*eci), GFP_KERNEL);
+	if (!eci)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, eci);
+	eci->dev = &pdev->dev;
+
+	ret = misc_register(&eci_device);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register misc_device: %d\n",
+				__LINE__);
+		goto err_misc;
+	}
+
+	the_eci = eci;
+
+	aci_callback.button_event       = aci_button_event;
+	aci_callback.priv               = eci;
+
+	eci_callback.event              = eci_accessory_event;
+	eci_callback.priv               = eci;
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &eci_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "could not create sysfs entries: %d\n",
+				__LINE__);
+		goto err_sysfs;
+	}
+
+	ret = init_accessory_input(eci);
+	if (ret) {
+		dev_err(&pdev->dev, "ERROR initializing accessory input: %d\n",
+				__LINE__);
+		goto err_input;
+	}
+
+	if (pdata) {
+		if (pdata->register_hsmic_event_cb) {
+			hsmic_event.private	= eci;
+			hsmic_event.event	= eci_hsmic_event;
+			pdata->register_hsmic_event_cb(&hsmic_event);
+		}
+
+		eci->jack_report = pdata->jack_report;
+	} else if (np) {
+		/* HACK
+		 * Simple way of setting this trought DT?
+		 * Use of_dev_auxdata only?
+		 */
+		hsmic_event.private = eci;
+		hsmic_event.event	= eci_hsmic_event;
+		dfl61_register_hsmic_event_cb(&hsmic_event);
+		eci->jack_report = dfl61_jack_report;
+	}
+
+	init_waitqueue_head(&eci->wait);
+	INIT_DELAYED_WORK(&eci->eci_ws, eci_work);
+
+	eci->mem_ok = false;
+	eci->mic_state = ECI_MIC_OFF;
+
+	/* Init buttons_data indexes and buffer. */
+	memset(&eci->buttons_data, 0, sizeof(struct eci_buttons_data));
+	eci->buttons_data.buttons = 0xffffffff;
+
+	return 0;
+
+err_input:
+	sysfs_remove_group(&pdev->dev.kobj, &eci_attr_group);
+
+err_sysfs:
+	misc_deregister(&eci_device);
+
+err_misc:
+
+	return ret;
+}
+
+static int eci_remove(struct platform_device *pdev)
+{
+	struct eci_data *eci = platform_get_drvdata(pdev);
+
+	cancel_delayed_work_sync(&eci->eci_ws);
+	sysfs_remove_group(&pdev->dev.kobj, &eci_attr_group);
+	remove_accessory_input(eci);
+	kfree(eci);
+	misc_deregister(&eci_device);
+
+	return 0;
+}
+
+static const struct of_device_id eci_of_match[] = {
+	{.compatible = "nokia,eci", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, eci_of_match);
+
+static struct platform_driver eci_driver = {
+	.probe		= eci_probe,
+	.remove		= eci_remove,
+	.driver		= {
+		.name	= ECI_DRIVERNAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= eci_of_match,
+	},
+};
+module_platform_driver(eci_driver);
+
+MODULE_ALIAS("platform:" ECI_DRIVERNAME);
+MODULE_AUTHOR("Nokia Corporation");
+MODULE_DESCRIPTION("ECI accessory driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 4ce3b6f11830..ea1748fe6039 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1379,6 +1379,23 @@ config MFD_TWL4030_AUDIO
	select MFD_CORE
	default n

+config TWL5031_ACI
+	tristate "TWL5031 ACI (Accessory Control Interface) Driver"
+	depends on TWL4030_CORE
+	select SND_JACK
+	select SND_OMAP_SOC_N9
+	help
+	The TWL5031 Accessory Control Interface functionality
+
+	TWL5031 ACI provides the following features:
+	- NAV (Nokia Audio/Video) periferals identification
+	- AV-connector resource handling
+	- DBI interface for battery identification
+
+	Say 'y' here to statically link this module into the kernel or 'm'
+	to build it as a dynamically loadable module. The module will be
+	called twl5031-aci.ko
+
 config TWL6040_CORE
	bool "TI TWL6040 audio codec"
	depends on I2C=y
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index dda4d4f73ad7..c570d9f9d9c4 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_MENELAUS)		+= menelaus.o
 obj-$(CONFIG_TWL4030_CORE)	+= twl-core.o twl4030-irq.o twl6030-irq.o
 obj-$(CONFIG_TWL4030_POWER)    += twl4030-power.o
 obj-$(CONFIG_MFD_TWL4030_AUDIO)	+= twl4030-audio.o
+obj-$(CONFIG_TWL5031_ACI)	+= twl5031-aci.o
 obj-$(CONFIG_TWL6040_CORE)	+= twl6040.o

 obj-$(CONFIG_MFD_MX25_TSADC)	+= fsl-imx25-tsadc.o
diff --git a/drivers/mfd/twl-core.c b/drivers/mfd/twl-core.c
index 7f10fb7e7bd0..31fafa69efaf 100644
--- a/drivers/mfd/twl-core.c
+++ b/drivers/mfd/twl-core.c
@@ -974,6 +974,14 @@ add_children(struct twl4030_platform_data *pdata, unsigned irq_base,
			return PTR_ERR(child);
	}

+	if (IS_ENABLED(CONFIG_TWL5031_ACI) && (features & TWL5031)) {
+		child = add_child(TWL5031_MODULE_ACCESSORY, "twl5031_aci",
+				pdata->aci, 0, false,
+				irq_base + ACI_INTR_OFFSET, 0);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
+	}
+
	if (IS_ENABLED(CONFIG_TWL4030_POWER) && pdata->power) {
		child = add_child(TWL_MODULE_PM_MASTER, "twl4030_power",
				  pdata->power, sizeof(*pdata->power), false,
diff --git a/drivers/mfd/twl5031-aci.c b/drivers/mfd/twl5031-aci.c
new file mode 100644
index 000000000000..65054ad1bde6
--- /dev/null
+++ b/drivers/mfd/twl5031-aci.c
@@ -0,0 +1,2080 @@
+/*
+ * This file is part of twl5031 ACI (Accessory Control Interface) driver
+ *
+ * Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * Contact: Tapio Vihuri <tapio.vihuri@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/gpio.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/err.h>
+#include <linux/i2c/twl.h>
+#include <linux/mfd/twl4030-audio.h>
+#include <linux/mfd/twl5031-aci.h>
+#include <linux/input/eci.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <sound/jack.h>
+#include <linux/i2c/twl4030-madc.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/pm_qos.h>
+#include <linux/slab.h>
+#include <sound/n9.h>
+
+#define ACI_DRIVERNAME	"twl5031_aci"
+
+/*
+ * plug need to be inserted fully before voltage is valid
+ * and user is slow
+ */
+#define ACI_WAIT_PLUG_ON_MIN		200	/* ms */
+#define ACI_WAIT_PLUG_ON_MAX		1000	/* ms */
+#define ACI_WAIT_PLUG_ON_DEFAULT	500	/* ms */
+#define ACI_WAIT_PLUG_TO_BUTTONS	200	/* ms */
+#define ACI_WAIT_CHECK_BUTTONS		20	/* ms */
+
+#define ACI_WAIT_PLUG_OFF		20	/* ms */
+#define ACI_WAIT_BUTTON			20	/* ms */
+#define ACI_WAIT_IRQ			100	/* ms */
+#define ACI_BUS_TIMEOUT			20	/* ms */
+#define ACI_BUS_SETTLE			25	/* ms */
+#define ACI_COMA_TIMEOUT		20	/* ms */
+#define ACI_WATCHDOG			200	/* ms */
+
+#define ACI_OPEN_CABLE_REDETECT_TIMER	1000	/* ms */
+#define ACI_DETECTS_NEEDED		2
+#define ACI_OPEN_CABLE_REDETECTS_NEEDED	(ACI_DETECTS_NEEDED * 2)
+#define ACI_OPEN_CABLE_REDETECTS	3
+#define ACI_REDETECTS_BAIL_OUT		(ACI_OPEN_CABLE_REDETECTS_NEEDED * \
+						ACI_OPEN_CABLE_REDETECTS * 2)
+
+#define ACI_BUTTON_TRESHOLD		200	/* mV */
+#define ACI_HEADPHONE_TRESHOLD		40	/* mV */
+#define ACI_AVOUT_TRESHOLD		500	/* mV */
+#define ACI_AHJ_NHJ_TRESHOLD		100	/* mV */
+#define ACI_BASIC_HEADSET_TRESHOLD	200	/* mV */
+#define ACI_BASIC_CARKIT_TRESHOLD	1075	/* mV */
+#define ACI_WAIT_VOLTAGE_SETTLING	20	/* ms */
+#define ACI_WAIT_VOLTAGE_SETTLING_LO	50000	/* us */
+#define ACI_WAIT_VOLTAGE_SETTLING_HI	52000	/* us */
+#define ACI_WAIT_COMPARATOR_SETTLING_LO	100	/* us */
+#define ACI_WAIT_COMPARATOR_SETTLING_HI	200	/* us */
+#define ACI_AVOUT_DETECTION_DELAY	200	/* ms */
+
+#define ACI_BUTTON_BUF_SIZE		32
+
+#define AV_ABOVE_600mV			0
+#define AV_BELOW_600mV			STATUS_A1_COMP
+
+#define ECI_IO_CMD			2
+#define ECI_DIRECT_MEM			1
+#define ECI_IO_CMD_READ			1
+#define ECI_IO_CMD_WRITE		3
+
+#define ECI_REAL_BUTTONS	false
+#define ECI_FORCE_BUTTONS_UP	true
+#define ECI_BUTTONS_LATCHED	true
+#define ECI_BUTTONS_NOT_LATCHED	false
+
+#define ACI_DETECTION_NONE	0
+#define ACI_DETECTION_BIAS_ON	1
+
+#define IO_READ_RETRY		3
+
+#define MADC_ADCIN10_PRESCALE(x)	((x) * 15 / 10)
+
+/* fixed in HW, do not change */
+enum {
+	ACICMD_NOP,
+	ACICMD_RST_LEARN,
+	ACICMD_SEND,
+	ACICMD_RECEIVE,
+	ACICMD_RECEIVE_LEARN,
+	NO_ACICMD,
+};
+
+enum {
+	ECI_NOP,
+	ECI_RST_LEARN,
+	ECI_WRITE_IO,
+	ECI_READ_IO,
+	ECI_READ_DIRECT,
+	ECI_OK,
+	ECI_ERROR,
+};
+
+enum {
+	ACI_TASK_NONE,
+	ACI_TASK_ENABLE_BUTTON,
+	ACI_TASK_GET_BUTTON,
+	ACI_TASK_SEND_BUTTON,
+	ACI_TASK_DETECTION,
+};
+
+enum {
+	ACI_AUDIO,
+	ACI_VIDEO,
+};
+
+/* Do not change order */
+enum {
+	ACI_BT_UP,
+	ACI_BT_DOWN,
+	ACI_BT_NONE,
+};
+
+enum {
+	ACI_NOTYPE,
+	ACI_UNKNOWN,
+	ACI_HEADPHONE,
+	ACI_AVOUT,
+	ACI_HEADSET,
+	ACI_ECI_HEADSET,
+	ACI_OPEN_CABLE,
+	ACI_CARKIT,
+};
+
+struct aci_irqs {
+	u8 accint;
+	u8 drec;
+	u8 dsent;
+	u8 spdset;
+	u8 commerr;
+	u8 fraerr;
+	u8 reserr;
+	u8 coll;
+	u8 nopint;
+};
+
+struct aci_buf {
+	u8	*buf;
+	int	count;
+};
+
+struct twl5031_aci {
+	struct device		*dev;
+	struct workqueue_struct *aci_wq;
+	struct delayed_work	aci_work;
+	struct delayed_work	plug_work;
+	struct delayed_work	wd_work;
+	struct work_struct	irq_work;
+	wait_queue_head_t	wait;
+	struct mutex		lock;	/* ACI transaction */
+	spinlock_t			irqlock;
+	struct mutex		iolock; /* IO reg read */
+	struct mutex		acc_block; /* accessory block operations */
+	int			tvout_gpio;
+	int			jack_gpio;
+	struct snd_soc_codec *codec;
+	struct regulator *v28;
+	int			v28_enabled;
+	int			vhsmicout;
+
+	bool		plugged;
+	int			avplugdet_plugged;
+
+	int			avswitch;
+	int			task;
+	int			bias_level;
+	char			*detected;
+	int			detection_latency;
+	int			detection_phase;
+	int			detection_count;
+	bool			open_cable_redetect_enabled;
+	int			open_cable_redetects;
+	int			accessory;
+	int			previous;
+	int			count;
+	int			needed;
+	int			button;
+	u8			buttons_buf[ACI_BUTTON_BUF_SIZE];
+	u8			windex;
+	u8			rindex;
+	int			eci_state;
+	int			version;
+	struct aci_buf		data;
+	u8			buf[4];
+	int			cmd;
+	int			op;
+	unsigned long		io_timeout;
+	u16			irq_bits;
+	u8			io_read_ongoing;
+	u8			eci_cmd;
+	struct aci_cb	*aci_callback;
+	struct eci_cb	*eci_callback;
+	struct aci_irqs		irqs;
+	bool			use_accint;
+	/* MADC measure stuff */
+	u16			rbuf[TWL4030_MADC_MAX_CHANNELS];
+
+	int			(*hw_plug_set_state)(struct device *dev,
+						bool plugged);
+	struct dev_pm_qos_request 	qos_request_acicmd;
+	struct dev_pm_qos_request 	qos_request_accint;
+};
+
+static int button = ACI_BT_UP;
+static struct twl5031_aci *the_aci;
+
+static int twl5031_aci_read(u8 reg);
+static void twl5031_aci_write(u8 reg, u8 val);
+static int twl5031_v_hs_mic_out(struct twl5031_aci *aci);
+static void twl5031_aci_set_av_output(struct twl5031_aci *aci, int audio);
+
+#ifdef CONFIG_DEBUG_FS
+static void twl5031_av_plug_on_off(struct twl5031_aci *aci);
+
+static struct dentry *aci_debugfs_dir;
+
+static void aci_dev_pm_qos_remove_request(struct dev_pm_qos_request *request)
+{
+	if (request->dev) {
+		dev_pm_qos_remove_request(request);
+		request->dev = NULL;
+	}
+}
+
+static ssize_t detected_read(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	struct twl5031_aci *aci = file->private_data;
+	char buffer[128];
+	int len;
+
+	len = snprintf(buffer, sizeof(buffer), "%s\n", aci->detected);
+	return simple_read_from_buffer(user_buf, count, ppos, buffer, len);
+}
+
+static ssize_t vhsmicout_read(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	struct twl5031_aci *aci = file->private_data;
+	char buffer[128];
+	int len;
+
+	len = snprintf(buffer, sizeof(buffer), "vhsmicout %04d mV\n",
+		twl5031_v_hs_mic_out(aci));
+	return simple_read_from_buffer(user_buf, count, ppos, buffer, len);
+}
+
+static ssize_t cable_read(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	struct twl5031_aci *aci = file->private_data;
+	char buffer[128];
+	int len;
+
+	len = snprintf(buffer, sizeof(buffer), "Cable plugged %s\n",
+		aci->plugged ? "in" : "out");
+	return simple_read_from_buffer(user_buf, count, ppos, buffer, len);
+}
+
+static ssize_t cable_write(struct file *file, const char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	struct twl5031_aci *aci = file->private_data;
+	char buf[32];
+	int buf_size;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (!memcmp(buf, "in", 2))
+		aci->plugged = true;
+	else if (!memcmp(buf, "out", 3))
+		aci->plugged = false;
+
+	twl5031_av_plug_on_off(aci);
+
+	return count;
+}
+
+static ssize_t avswitch_read(struct file *file, char __user *user_buf,
+		size_t count, loff_t *ppos)
+{
+	struct twl5031_aci *aci = file->private_data;
+	char buffer[128];
+	int len;
+
+	switch (aci->avswitch) {
+	case ACI_AUDIO:
+		len = snprintf(buffer, sizeof(buffer), "avswitch audio\n");
+		break;
+	case ACI_VIDEO:
+		len = snprintf(buffer, sizeof(buffer), "avswitch video\n");
+		break;
+	default:
+		len = snprintf(buffer, sizeof(buffer),
+			"ERROR avswitch unknown state\n");
+		break;
+	}
+	return simple_read_from_buffer(user_buf, count, ppos, buffer, len);
+}
+
+static ssize_t avswitch_write(struct file *file, const char __user *user_buf,
+			      size_t count, loff_t *ppos)
+{
+	struct twl5031_aci *aci = file->private_data;
+	char buf[32];
+	ssize_t buf_size;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (!memcmp(buf, "audio", 5))
+		aci->avswitch = ACI_AUDIO;
+	else if (!memcmp(buf, "video", 5))
+		aci->avswitch = ACI_VIDEO;
+
+	twl5031_aci_set_av_output(aci, aci->avswitch);
+
+	return count;
+}
+
+static int default_open(struct inode *inode, struct file *file)
+{
+	if (inode->i_private)
+		file->private_data = inode->i_private;
+
+	return 0;
+}
+
+static const struct file_operations detected_fops = {
+	.open		= default_open,
+	.read		= detected_read,
+};
+
+static const struct file_operations vhsmicout_fops = {
+	.open		= default_open,
+	.read		= vhsmicout_read,
+};
+
+static const struct file_operations cable_fops = {
+	.open		= default_open,
+	.read		= cable_read,
+	.write		= cable_write,
+};
+
+static const struct file_operations avswitch_fops = {
+	.open		= default_open,
+	.read		= avswitch_read,
+	.write		= avswitch_write,
+};
+
+static void aci_uninitialize_debugfs(void)
+{
+	if (aci_debugfs_dir)
+		debugfs_remove_recursive(aci_debugfs_dir);
+}
+
+static long aci_initialize_debugfs(struct twl5031_aci *aci)
+{
+	void *ok;
+
+	/* /sys/kernel/debug/twl5031_aci */
+	aci_debugfs_dir = debugfs_create_dir(dev_name(aci->dev), NULL);
+	if (IS_ERR(aci_debugfs_dir)) {
+		/* assume -ENODEV */
+		dev_err(aci->dev, "debugfs not enabled: %d\n", __LINE__);
+		return PTR_ERR(aci_debugfs_dir);
+	}
+	if (!aci_debugfs_dir)
+		return 0;
+
+	ok = debugfs_create_file("detected", S_IRUGO, aci_debugfs_dir,
+			aci, &detected_fops);
+	if (!ok)
+		goto fail;
+	ok = debugfs_create_file("vhsmicout", S_IRUGO, aci_debugfs_dir,
+			aci, &vhsmicout_fops);
+	if (!ok)
+		goto fail;
+	ok = debugfs_create_file("cable", S_IRUGO | S_IWUSR,
+			aci_debugfs_dir, aci, &cable_fops);
+	if (!ok)
+		goto fail;
+	ok = debugfs_create_file("avswitch", S_IRUGO | S_IWUSR, aci_debugfs_dir,
+			aci, &avswitch_fops);
+	if (!ok)
+		goto fail;
+
+	return PTR_ERR(ok);
+fail:
+	aci_uninitialize_debugfs();
+	return PTR_ERR(ok);
+}
+#else
+#define aci_initialize_debugfs(aci)	1
+#define aci_uninitialize_debugfs()
+#endif
+
+static int twl5031_aci_read(u8 reg)
+{
+	int ret;
+	u8 val;
+
+	ret = twl_i2c_read_u8(TWL5031_MODULE_ACCESSORY, &val, reg);
+	if (ret) {
+		pr_err("unable to read register 0x%X: %d\n", reg, __LINE__);
+		return ret;
+	}
+
+	return val;
+}
+
+static void twl5031_aci_write(u8 reg, u8 val)
+{
+	int ret;
+
+	ret = twl_i2c_write_u8(TWL5031_MODULE_ACCESSORY, val, reg);
+	if (ret)
+		pr_err("unable to write register 0x%X: %d\n", reg, __LINE__);
+}
+
+static void twl5031_aci_enable_irqs(u16 mask)
+{
+	u16 val;
+
+	val = twl5031_aci_read(TWL5031_ACIIMR_MSB) << 8;
+	val |= twl5031_aci_read(TWL5031_ACIIMR_LSB);
+	val &= ~mask;
+	twl5031_aci_write(TWL5031_ACIIMR_LSB, val);
+	twl5031_aci_write(TWL5031_ACIIMR_MSB, val >> 8);
+}
+
+static void twl5031_aci_disable_irqs(u16 mask)
+{
+	u16 val;
+
+	val = twl5031_aci_read(TWL5031_ACIIMR_MSB) << 8;
+	val |= twl5031_aci_read(TWL5031_ACIIMR_LSB);
+	val |= mask;
+	twl5031_aci_write(TWL5031_ACIIMR_LSB, val);
+	twl5031_aci_write(TWL5031_ACIIMR_MSB, val >> 8);
+}
+
+/*
+ * ACI ASIC fall into coma giving just ACI_COMMERR status
+ * it should return to idle state after any error
+ * but this seems not to be the case sometimes with ACI_COMMERR
+ * strangly enough, ACI_COMMERR and ACI_FRAERR together gives no problem
+ */
+static void twl5031_aci_out_of_coma(void)
+{
+	msleep(ACI_COMA_TIMEOUT);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL,
+			ACI_DISABLE | ACI_ACCESSORY_MODE);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL,
+			ACI_ENABLE | ACI_ACCESSORY_MODE);
+	msleep(ACI_COMA_TIMEOUT);
+}
+
+/* select mic bias sleep mode versus normal */
+static void twl5031_mic_bias_mode(u8 param)
+{
+	u8 val, on;
+
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	if (param == ECI_MIC_OFF) {
+		val |= HOOK_DET_EN_SLEEP_MODE;
+		on = 0;
+	} else {
+		val &= ~HOOK_DET_EN_SLEEP_MODE;
+		on = 1;
+	}
+
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, val);
+	dfl61_request_hsmicbias(on);
+}
+
+static int twl5031_aci_cmd(u8 task)
+{
+	long timein;
+	u8 cmd;
+	int ret = 0;
+
+	the_aci->op = task;
+	switch (task) {
+	case ECI_NOP:
+		cmd = ACICMD_NOP;
+		break;
+	case ECI_RST_LEARN:
+		cmd = ACICMD_RST_LEARN;
+		break;
+	case ECI_READ_IO:
+	case ECI_WRITE_IO:
+	case ECI_READ_DIRECT:
+		cmd = ACICMD_SEND;
+	break;
+	default:
+		dev_err(the_aci->dev, "UNUSED ACI op %d: %d\n", the_aci->op,
+				__LINE__);
+		return -EINVAL;
+	}
+
+	the_aci->cmd = cmd;
+	twl5031_aci_enable_irqs(ACI_INTERNAL);
+
+	/* clear out "used" interrupt */
+	the_aci->eci_state = 0;
+	memset(&the_aci->irqs, 0, sizeof(struct aci_irqs));
+	dev_pm_qos_add_request(the_aci->dev, &the_aci->qos_request_acicmd,
+							PM_QOS_CPU_DMA_LATENCY, 0);
+
+	twl5031_aci_write(TWL5031_ACICOMR_LSB, cmd);
+
+	/*
+	 * eci_state set in twl5031_aci_irq_handler
+	 * then we sit and wait all ACI/ECI communication to happens.
+	 * We need to prevent all kind of idle activity by setting
+	 * pm_qos_requirements
+	 */
+	timein = wait_event_timeout(the_aci->wait,
+				(the_aci->op == ECI_ERROR ||
+					the_aci->op == ECI_OK),
+				msecs_to_jiffies(ACI_WAIT_IRQ));
+
+	twl5031_aci_disable_irqs(ACI_INTERNAL);
+	aci_dev_pm_qos_remove_request(&the_aci->qos_request_acicmd);
+
+	/* meaning timeout */
+	if (the_aci->cmd != NO_ACICMD)
+		return -EAGAIN;
+
+	/* This seems to be necessary. Reason unknown */
+	usleep_range(1000, 1100);
+
+	if (the_aci->op == ECI_ERROR) {
+		ret = (the_aci->irqs.commerr ? ACI_COMMERR : 0) |
+			(the_aci->irqs.fraerr ? ACI_FRAERR : 0) |
+			(the_aci->irqs.reserr ? ACI_RESERR : 0) |
+			(the_aci->irqs.coll ? ACI_COLL : 0);
+	}
+
+	if (ret) {
+		msleep(ACI_COMA_TIMEOUT);
+		if (ret == ACI_COMMERR)
+			twl5031_aci_out_of_coma();
+	}
+
+	return ret;
+}
+
+/* reset ECI accessory */
+static int twl5031_acc_reset(void)
+{
+	int err;
+
+	mutex_lock(&the_aci->lock);
+
+	err = twl5031_aci_cmd(ECI_RST_LEARN);
+
+	mutex_unlock(&the_aci->lock);
+
+	return err;
+}
+
+/* up to four bytes */
+static int twl5031_acc_read_reg(u8 reg, u8 *buf, int count)
+{
+	int err;
+
+	mutex_lock(&the_aci->lock);
+
+	/* clear out "used" interrupt
+	 * eci_state set in twl5031_aci_irq_handler
+	 */
+	the_aci->eci_state = 0;
+
+	the_aci->eci_cmd = reg << ECI_IO_CMD | ECI_IO_CMD_READ;
+	the_aci->data.buf = buf;
+	the_aci->data.count = count;
+
+	err = twl5031_aci_cmd(ECI_READ_IO);
+
+	mutex_unlock(&the_aci->lock);
+
+	return err;
+}
+
+static int twl5031_acc_write_reg(u8 reg, u8 param)
+{
+	int err;
+
+	mutex_lock(&the_aci->lock);
+	twl5031_aci_disable_irqs(ACI_ACCINT);
+
+	/* clear out "used" interrupt
+	 * eci_state set in twl5031_aci_irq_handler
+	 */
+	the_aci->eci_state = 0;
+
+	the_aci->eci_cmd = reg << ECI_IO_CMD | ECI_IO_CMD_WRITE;
+	the_aci->data.buf = &param;
+
+	err = twl5031_aci_cmd(ECI_WRITE_IO);
+
+	mutex_unlock(&the_aci->lock);
+
+	/* use eci_hsmic_event from ECI driver to control micbias sleep mode */
+	if (reg == ECICMD_MIC_CTRL) {
+		twl5031_mic_bias_mode(param);
+		if (the_aci->use_accint) {
+			twl5031_aci_write(TWL5031_ACIIDR_LSB, ACI_ACCINT);
+			/* We need to wait mic line settling */
+			msleep(ACI_BUS_SETTLE);
+			twl5031_aci_write(TWL5031_ACIIDR_LSB, ACI_ACCINT);
+			twl5031_aci_enable_irqs(ACI_ACCINT);
+		}
+	}
+
+	return err;
+}
+
+/* read always four bytes */
+static int twl5031_acc_read_direct(u8 addr, char *buf)
+{
+	int err;
+
+	mutex_lock(&the_aci->lock);
+
+	the_aci->eci_cmd = addr << ECI_DIRECT_MEM;
+	the_aci->data.buf = buf;
+	the_aci->data.count = 4;
+
+	/* start action, wait untill communication done
+	 * work done in twl5031_aci_irq_handler, ie. update buf
+	 */
+	err = twl5031_aci_cmd(ECI_READ_DIRECT);
+
+	mutex_unlock(&the_aci->lock);
+
+	return err;
+}
+
+void static twl5031_read_buttons(struct twl5031_aci *aci, bool latched)
+{
+	struct eci_data *eci = aci->eci_callback->priv;
+	u8 cmd;
+
+	if (latched)
+		cmd = ECICMD_LATCHED_PORT_DATA_0;
+	else
+		cmd = ECICMD_PORT_DATA_0;
+
+	dev_pm_qos_add_request(the_aci->dev, &aci->qos_request_accint,
+							PM_QOS_CPU_DMA_LATENCY, 0);
+
+	aci->io_read_ongoing = IO_READ_RETRY;
+	aci->io_timeout = msecs_to_jiffies(ACI_WATCHDOG) + jiffies;
+
+	memset(&aci->irqs, 0, sizeof(struct aci_irqs));
+	aci->op = ECI_READ_IO;
+	aci->eci_cmd = cmd << ECI_IO_CMD | ECI_IO_CMD_READ;
+
+	aci->data.buf = aci->buf;
+	aci->data.count = eci->port_reg_count;
+
+	twl5031_aci_disable_irqs(ACI_COLL);
+	twl5031_aci_enable_irqs(ACI_INTERNAL & ~ACI_COLL);
+
+	twl5031_aci_write(TWL5031_ACICOMR_LSB, ACICMD_SEND);
+
+	queue_delayed_work(aci->aci_wq, &aci->wd_work,
+			msecs_to_jiffies(ACI_WATCHDOG));
+}
+
+void static twl5031_reread_buttons(struct twl5031_aci *aci)
+{
+	struct eci_data *eci = aci->eci_callback->priv;
+
+	/* debug prints change the behaviour, so be careful */
+	dev_vdbg(aci->dev, "ECI button read %s%s%s%sat: %d\n",
+			aci->irqs.commerr ? "COMMERR " : "",
+			aci->irqs.fraerr ? "FRAERR " : "",
+			aci->irqs.reserr ? "RESERR " : "",
+			aci->irqs.coll ? "COLLERR " : "",
+			__LINE__);
+
+	if (aci->irqs.commerr) {
+		twl5031_aci_out_of_coma();
+		twl5031_aci_enable_irqs(ACI_INTERNAL);
+	}
+
+	memset(&aci->irqs, 0, sizeof(struct aci_irqs));
+	aci->io_read_ongoing--;
+
+	aci->op = ECI_READ_IO;
+	aci->eci_cmd =
+		ECICMD_LATCHED_PORT_DATA_0 << ECI_IO_CMD | ECI_IO_CMD_READ;
+
+	aci->data.buf = aci->buf;
+	aci->data.count = eci->port_reg_count;
+
+	twl5031_aci_write(TWL5031_ACICOMR_LSB, ACICMD_SEND);
+}
+
+void static twl5031_emit_buttons(struct twl5031_aci *aci, bool force_up)
+{
+	struct eci_data *eci = aci->eci_callback->priv;
+	struct eci_buttons_data *b = &eci->buttons_data;
+
+	aci_dev_pm_qos_remove_request(&aci->qos_request_accint);
+	b->buttons = cpu_to_le32(*(u32 *)aci->data.buf);
+
+	if (force_up)
+		b->buttons = b->buttons_up_mask;
+
+	aci->eci_callback->event(ECI_EVENT_BUTTON, aci->eci_callback->priv);
+
+	aci->io_read_ongoing = 0;
+	twl5031_aci_write(TWL5031_ACIIDR_LSB, ACI_ACCINT);
+
+	twl5031_aci_disable_irqs(ACI_INTERNAL);
+	aci->use_accint = true;
+	twl5031_aci_enable_irqs(ACI_ACCINT);
+}
+
+/*
+ * This is ran when driver start or at plug off event.
+ * Only other places to touch this buffer are twl5031_get_av_button() and
+ * twl5031_send_av_button().
+ *
+ * It's quaranteed that aci->plugged is false when this is ran.
+ */
+static void twl5031_buttons_buf_clear(struct twl5031_aci *aci)
+{
+	int i;
+
+	for (i = 0; i < ACI_BUTTON_BUF_SIZE; i++)
+		aci->buttons_buf[i] = ACI_BT_NONE;
+
+	aci->rindex = 0;
+	aci->windex = 0;
+}
+
+/*
+ * Only non ECI headset button case may trigger this.
+ *
+ * It means ACI_ACCINT interrupt if and only if accessory type is either
+ * ACI_HEADSET or ACI_CARKIT.
+ *
+ * It is OK to add button events even during twl5031_send_av_button().
+ */
+static void twl5031_get_av_button(struct twl5031_aci *aci)
+{
+	u16 val;
+
+	/* do not modify buffer if plug is already removed */
+	if (!aci->plugged)
+		return;
+
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, AV_COMP1_EN);
+	usleep_range(ACI_WAIT_COMPARATOR_SETTLING_LO,
+		ACI_WAIT_COMPARATOR_SETTLING_HI);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	if (val & STATUS_A1_COMP)
+		aci->button = ACI_BT_DOWN;
+	else
+		aci->button = ACI_BT_UP;
+
+	if (aci->button != button) {
+		if (aci->windex < ACI_BUTTON_BUF_SIZE) {
+			if (aci->buttons_buf[aci->windex] == ACI_BT_NONE) {
+				aci->buttons_buf[aci->windex] = aci->button;
+			} else
+				dev_err(aci->dev,
+						"ACI button queue overflow\n");
+		}
+		aci->windex++;
+		if (aci->windex == ACI_BUTTON_BUF_SIZE)
+			aci->windex = 0;
+	}
+
+	button = aci->button;
+
+	/* trigger twl5031_send_av_button() */
+	aci->task = ACI_TASK_SEND_BUTTON;
+	queue_delayed_work(aci->aci_wq, &aci->aci_work,
+			msecs_to_jiffies(ACI_WAIT_PLUG_TO_BUTTONS));
+}
+
+/* Only task ACI_TASK_SEND_BUTTON may trigger this.
+ * Only twl5031_get_av_button() may set ACI_TASK_SEND_BUTTON.
+ */
+static void twl5031_send_av_button(struct twl5031_aci *aci)
+{
+	int i, btn;
+
+	for (i = 0; i < ACI_BUTTON_BUF_SIZE; i++) {
+		btn = aci->buttons_buf[aci->rindex];
+		/* do not modify buffer if plug is already removed */
+		if (btn == ACI_BT_NONE || !aci->plugged)
+			break;
+
+		aci->aci_callback->button_event(btn, aci->aci_callback->priv);
+
+		aci->buttons_buf[aci->rindex] = ACI_BT_NONE;
+		aci->rindex++;
+		if (aci->rindex == ACI_BUTTON_BUF_SIZE)
+			aci->rindex = 0;
+	}
+
+	if (aci->button == ACI_BT_DOWN) {
+		/* trigger twl5031_get_av_button() */
+		aci->task = ACI_TASK_GET_BUTTON;
+		queue_delayed_work(aci->aci_wq, &aci->aci_work,
+				msecs_to_jiffies(ACI_WAIT_CHECK_BUTTONS));
+	} else {
+		aci->irqs.accint = 0;
+		twl5031_aci_enable_irqs(ACI_ACCINT);
+	}
+}
+
+/*
+ * ACI irq (374)
+ * ACI commands responces, errors or accessory interrupts
+ */
+static irqreturn_t twl5031_aci_irq_thread(int irq, void *_aci)
+{
+	struct twl5031_aci *aci = _aci;
+	unsigned long flags;
+	u16 val;
+	int res;
+
+	/* read TWL5031_ACIIDR_LSB & TWL5031_ACIIDR_MSB */
+	/*twl_set_regcache_bypass(TWL5031_MODULE_ACCESSORY, true);*/
+	res = twl_i2c_read_u16(TWL5031_MODULE_ACCESSORY, &val,
+							TWL5031_ACIIDR_LSB);
+	/*twl_set_regcache_bypass(TWL5031_MODULE_ACCESSORY, false);*/
+	if (res) {
+		dev_err(aci->dev, "Failed to read ACIIDR\n");
+		return IRQ_HANDLED;
+	}
+
+	/* write TWL5031_ACIIDR_LSB & TWL5031_ACIIDR_MSB to clear IRQ*/
+	res = twl_i2c_write_u16(TWL5031_MODULE_ACCESSORY, val,
+							TWL5031_ACIIDR_LSB);
+	if (res) {
+		dev_err(aci->dev, "Failed to write ACIIDR\n");
+	}
+
+	/*
+	 * disregard queued ACI_ACCINT irqs if io_read_ongoing
+	 */
+	if (aci->io_read_ongoing)
+		val &= ~ACI_ACCINT;
+
+	if (val) {
+		spin_lock_irqsave(&aci->irqlock, flags);
+		aci->irq_bits |= val;
+		spin_unlock_irqrestore(&aci->irqlock, flags);
+		schedule_work(&aci->irq_work);
+	}
+
+	return IRQ_HANDLED;
+};
+
+static void twl5031_irq_work(struct work_struct *work)
+{
+	struct twl5031_aci *aci = container_of(work, struct twl5031_aci,
+											irq_work);
+	u16 val;
+	int res;
+
+	spin_lock_bh(&aci->irqlock);
+	val = aci->irq_bits;
+	aci->irq_bits = 0;
+	spin_unlock_bh(&aci->irqlock);
+
+	//printk(KERN_ERR "%s, val: %x\n", __func__, val);
+
+	if (val & ACI_ACCINT)
+		aci->irqs.accint++;
+	if (val & ACI_DREC)
+		aci->irqs.drec++;
+	if (val & ACI_DSENT)
+		aci->irqs.dsent++;
+	if (val & ACI_SPDSET)
+		aci->irqs.spdset++;
+	if (val & ACI_COMMERR)
+		aci->irqs.commerr++;
+	if (val & ACI_FRAERR)
+		aci->irqs.fraerr++;
+	if (val & ACI_RESERR)
+		aci->irqs.reserr++;
+	if (val & ACI_COLL)
+		aci->irqs.coll++;
+	if (val & ACI_NOPINT)
+		aci->irqs.nopint++;
+
+	/* ECI headset button */
+	if (aci->irqs.accint && aci->accessory == ACI_ECI_HEADSET &&
+		aci->task == ACI_TASK_NONE) {
+
+		aci->use_accint = false;
+		twl5031_aci_disable_irqs(ACI_ACCINT);
+
+		cancel_delayed_work_sync(&aci->wd_work);
+
+		mutex_lock(&aci->iolock);
+
+		if (aci->io_read_ongoing)
+			dev_err(aci->dev, "Should not get button interrupt"
+				" during IO reg reading\n");
+		else
+			twl5031_read_buttons(aci, ECI_BUTTONS_LATCHED);
+
+		mutex_unlock(&aci->iolock);
+		/* Remove possible pending interrupt */
+		spin_lock_bh(&aci->irqlock);
+		aci->irq_bits &= ~ACI_ACCINT;
+		spin_unlock_bh(&aci->irqlock);
+	}
+
+	/* order of if's are important */
+	switch (aci->op) {
+	case ECI_NOP:
+		if (aci->irqs.commerr || aci->irqs.fraerr ||
+				aci->irqs.reserr || aci->irqs.coll) {
+			aci->cmd = NO_ACICMD;
+			aci->op = ECI_ERROR;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.nopint) {
+			aci->op = ECI_OK;
+			aci->cmd = NO_ACICMD;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		break;
+	case ECI_RST_LEARN:
+		if (aci->irqs.spdset) {
+			aci->op = ECI_OK;
+			aci->cmd = NO_ACICMD;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.reserr) {
+			aci->op = ECI_ERROR;
+			aci->cmd = NO_ACICMD;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		break;
+	case ECI_WRITE_IO:
+		if (aci->irqs.commerr || aci->irqs.fraerr ||
+				aci->irqs.reserr || aci->irqs.coll) {
+			aci->cmd = NO_ACICMD;
+			aci->op = ECI_ERROR;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.nopint == 1) {
+			aci->op = ECI_OK;
+			aci->cmd = NO_ACICMD;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.dsent == 3) {
+			twl5031_aci_write(TWL5031_ACICOMR_LSB, ACICMD_NOP);
+			goto out;
+		}
+		if (aci->irqs.dsent == 2) {
+			twl5031_aci_write(TWL5031_ACITXDAR, aci->data.buf[0]);
+			goto out;
+		}
+		if (aci->irqs.dsent == 1) {
+			twl5031_aci_write(TWL5031_ACITXDAR, aci->eci_cmd);
+			goto out;
+		}
+		break;
+	case ECI_READ_IO:
+		/*
+		 * there was error reading IO reg
+		 */
+		if (aci->irqs.commerr || aci->irqs.fraerr ||
+				aci->irqs.reserr || aci->irqs.coll) {
+			aci->cmd = NO_ACICMD;
+			aci->op = ECI_ERROR;
+			/* Wait outside mutex until bus traffic is finished. */
+			msleep(ACI_BUS_TIMEOUT);
+			mutex_lock(&aci->iolock);
+			if (aci->io_read_ongoing > 1)
+				twl5031_reread_buttons(aci);
+			else
+				twl5031_aci_disable_irqs(ACI_INTERNAL);
+			mutex_unlock(&aci->iolock);
+			wake_up(&aci->wait);
+			goto out;
+		}
+		/* IO reg read OK */
+		if (aci->irqs.nopint == 2) {
+			aci->cmd = NO_ACICMD;
+			aci->op = ECI_OK;
+			mutex_lock(&aci->iolock);
+			if (aci->io_read_ongoing)
+				/* enable ACCINT */
+				twl5031_emit_buttons(aci, ECI_REAL_BUTTONS);
+			mutex_unlock(&aci->iolock);
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.drec) {
+			res = twl5031_aci_read(TWL5031_ACIRXDAR);
+			if (aci->irqs.drec > 4)
+				goto out;
+			aci->data.buf[aci->irqs.drec-1] = res;
+			if (aci->irqs.drec == aci->data.count)
+				twl5031_aci_write(TWL5031_ACICOMR_LSB,
+						ACICMD_NOP);
+			goto out;
+		}
+		if (aci->irqs.spdset == 1)
+			goto out;
+		if (aci->irqs.nopint == 1) {
+			twl5031_aci_write(TWL5031_ACICOMR_LSB,
+					ACICMD_RECEIVE_LEARN);
+			goto out;
+		}
+		if (aci->irqs.dsent == 2) {
+			twl5031_aci_write(TWL5031_ACICOMR_LSB, ACICMD_NOP);
+			goto out;
+		}
+		/* IO reg read start with read command */
+		if (aci->irqs.dsent == 1) {
+			twl5031_aci_write(TWL5031_ACITXDAR, aci->eci_cmd);
+			goto out;
+		}
+		break;
+	case ECI_READ_DIRECT:
+		if (aci->irqs.commerr || aci->irqs.fraerr ||
+				aci->irqs.reserr || aci->irqs.coll) {
+			aci->cmd = NO_ACICMD;
+			aci->op = ECI_ERROR;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.nopint == 2) {
+			aci->cmd = NO_ACICMD;
+			aci->op = ECI_OK;
+			wake_up(&aci->wait);
+			goto out;
+		}
+		if (aci->irqs.drec) {
+			res = twl5031_aci_read(TWL5031_ACIRXDAR);
+			if (aci->irqs.drec > 4)
+				goto out;
+			aci->data.buf[aci->irqs.drec-1] = res;
+			if (aci->irqs.drec == aci->data.count)
+				twl5031_aci_write(TWL5031_ACICOMR_LSB,
+						ACICMD_NOP);
+			goto out;
+		}
+		if (aci->irqs.spdset == 1)
+			goto out;
+		if (aci->irqs.nopint == 1) {
+			twl5031_aci_write(TWL5031_ACICOMR_LSB,
+					ACICMD_RECEIVE_LEARN);
+			goto out;
+		}
+		if (aci->irqs.dsent == 2) {
+			twl5031_aci_write(TWL5031_ACICOMR_LSB, ACICMD_NOP);
+			goto out;
+		}
+		if (aci->irqs.dsent == 1) {
+			twl5031_aci_write(TWL5031_ACITXDAR, aci->eci_cmd);
+			goto out;
+		}
+		break;
+	case ECI_OK:
+		break;
+	case ECI_ERROR:
+		break;
+	default:
+		dev_err(aci->dev, "unknown ACI op %d: %d\n", aci->op, __LINE__);
+		break;
+
+out:
+	return;
+	}
+
+	/* non ECI headset button */
+	if (aci->irqs.accint && (aci->accessory == ACI_HEADSET ||
+				aci->accessory == ACI_CARKIT)) {
+		twl5031_aci_disable_irqs(ACI_ACCINT);
+		twl5031_get_av_button(aci);
+	}
+}
+
+/*
+ * AvPlugDet irq
+ * ie. jack_gpio, polarity stated in avplugdet_plugged
+ */
+static irqreturn_t twl5031_plugdet_irq_handler(int irq, void *_aci)
+{
+	struct twl5031_aci *aci = _aci;
+	int delay, avplugdet;
+
+	dev_dbg(aci->dev, "AvPlugDet interrupt\n");
+
+	avplugdet = gpio_get_value_cansleep(aci->jack_gpio);
+	aci->plugged = (avplugdet == aci->avplugdet_plugged);
+
+	if (aci->plugged) {
+		/* Order delayed mic bias on event */
+		delay = aci->detection_latency - ACI_WAIT_PLUG_ON_MIN;
+		aci->detection_phase = ACI_DETECTION_BIAS_ON;
+	} else {
+		delay = ACI_WAIT_PLUG_OFF;
+	}
+
+	/* start accessory detection */
+	queue_delayed_work(aci->aci_wq, &aci->plug_work,
+			msecs_to_jiffies(delay));
+
+	return IRQ_HANDLED;
+}
+
+static void twl5031_aci_set_av_output(struct twl5031_aci *aci, int mode)
+{
+	if (mode == ACI_AUDIO)
+		gpio_set_value(aci->tvout_gpio, 0);
+	else
+		gpio_set_value(aci->tvout_gpio, 1);
+}
+
+static int twl5031_v_hs_mic_out(struct twl5031_aci *aci)
+{
+	int ret;
+
+	ret = twl4030_get_madc_conversion(ACI_MADC_CHANNEL);
+	aci->vhsmicout = MADC_ADCIN10_PRESCALE(ret);
+
+	return aci->vhsmicout;
+}
+
+/*
+ * detects these accessory types:
+ * headphones
+ * video cable
+ * ECI
+ * open cable
+ * basic headset
+ * basic carkit
+ */
+static int twl5031_av_detection(struct twl5031_aci *aci)
+{
+	int ret, old;
+	u8 val;
+
+	dfl61_request_hp_enable(0);
+	dev_dbg(aci->dev, "AV detection\n");
+
+	/* We don't need debounce here */
+	val = twl5031_aci_read(TWL5031_ACI_AUDIO_CTRL);
+	val |= HOOK_DEB_BYPASS;
+	twl5031_aci_write(TWL5031_ACI_AUDIO_CTRL, val);
+
+	/* Enable ACI block and disconnect pull ups == DBI MODE */
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_ENABLE | ACI_DBI_MODE);
+	dfl61_request_hsmicbias(1);
+	msleep(ACI_WAIT_VOLTAGE_SETTLING);
+
+	/* MADC measurement path enabled */
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, ADC_SW_EN);
+
+	/* Check for wrong pinout accessories using HP amplifier */
+	old = twl5031_v_hs_mic_out(aci);
+	dfl61_request_hp_enable(1);
+	msleep(ACI_WAIT_VOLTAGE_SETTLING);
+	ret = twl5031_v_hs_mic_out(aci);
+	dfl61_request_hp_enable(0);
+	if (old > ret)
+		if (old - ret > ACI_AHJ_NHJ_TRESHOLD)
+			return ACI_UNKNOWN;
+
+	/*
+	 * MADC measurement path and comparator 1 enabled.
+	 * All pull ups disabled.
+	 */
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, ADC_SW_EN | AV_COMP1_EN);
+	usleep_range(ACI_WAIT_COMPARATOR_SETTLING_LO,
+		ACI_WAIT_COMPARATOR_SETTLING_HI);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	/* headphones or video cable */
+	if (val & STATUS_A1_COMP) {
+		ret = twl5031_v_hs_mic_out(aci);
+		if (ret < ACI_HEADPHONE_TRESHOLD)
+			return ACI_HEADPHONE;
+		if (ret < ACI_AVOUT_TRESHOLD)
+			return ACI_AVOUT;
+	}
+
+	/* was not headphones or video cable, try ECI */
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL,
+			ACI_ENABLE | ACI_ACCESSORY_MODE);
+
+	/*
+	 * try several times to make sure ECI accessory has initialized
+	 * itself after enabling voltage for it
+	 * drawback is slowering detection of open cable and basic
+	 * headset & carkit
+	 */
+	mutex_lock(&the_aci->lock);
+	for (val = 0; val < 10; val++) {
+		ret = twl5031_aci_cmd(ECI_RST_LEARN);
+		if (!ret)
+			break;
+	}
+	mutex_unlock(&the_aci->lock);
+
+	/* ECI */
+	if (!ret) {
+		dfl61_request_hsmicbias(1);
+		return ACI_ECI_HEADSET;
+	}
+
+	/*
+	 * was not ECI, try open cable
+	 * Only comparator 2 pull up enabled
+	 */
+	dfl61_request_hsmicbias(0);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_ENABLE | ACI_DBI_MODE);
+	val = AV_COMP2_EN | ADC_SW_EN;
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, val);
+	usleep_range(ACI_WAIT_VOLTAGE_SETTLING_LO,
+		ACI_WAIT_VOLTAGE_SETTLING_HI);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	/* open cable, ie lineout */
+	if (!(val & STATUS_A2_COMP))
+		return ACI_OPEN_CABLE;
+
+	ret = twl5031_v_hs_mic_out(aci);
+	/*
+	 * was not open cable, try basic headset or carkit.
+	 * Pull ups disabled, regulators off. Regulator output grounded.
+	 * i.e. measure voltage drop across serial resistor.
+	 */
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, ADC_SW_EN | HSM_GROUNDED_EN);
+	msleep(ACI_WAIT_VOLTAGE_SETTLING);
+
+	/* basic headset */
+	ret = twl5031_v_hs_mic_out(aci);
+	/* sane settings _after_ measuring voltage */
+	val = AV_COMP1_EN | HOOK_DET_EN;
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, val);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL,
+			ACI_ENABLE | ACI_ACCESSORY_MODE);
+	if (ret < ACI_BASIC_HEADSET_TRESHOLD)
+		return ACI_HEADSET;
+
+	/* basic carkit */
+	if (ret > ACI_BASIC_CARKIT_TRESHOLD)
+		return ACI_CARKIT;
+
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, 0);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_DISABLE | ACI_DBI_MODE);
+
+	return ACI_UNKNOWN;
+}
+
+static void twl5031_disable_pullups(void)
+{
+	u8 val;
+
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_DISABLE | ACI_DBI_MODE);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+	val &= ~AV_COMP2_EN;
+	val &= ~HOOK_DET_EN_SLEEP_MODE;
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, val);
+}
+
+static void twl5031_av_plug_on_off(struct twl5031_aci *aci)
+{
+	mutex_lock(&aci->acc_block);
+
+	twl5031_aci_disable_irqs(ACI_INTERNAL | ACI_ACCINT);
+	twl5031_buttons_buf_clear(aci);
+
+	/* plug off */
+	if (!aci->plugged) {
+		/* force ECI headset buttons up event */
+		if (aci->accessory == ACI_ECI_HEADSET)
+			twl5031_emit_buttons(aci, ECI_FORCE_BUTTONS_UP);
+		twl5031_aci_disable_irqs(ACI_ACCINT);
+		/* force basic headset button up event */
+		aci->aci_callback->button_event(0, aci->aci_callback->priv);
+
+		button = ACI_BT_UP;
+
+		/* pm settings */
+		if (aci->v28_enabled) {
+			if (regulator_disable(aci->v28))
+				aci->v28_enabled = false;
+		}
+
+		dfl61_jack_report(0);
+		aci->detected = "AV jack removed";
+		dev_emerg(aci->dev, "%s\n", aci->detected);
+		dfl61_request_hsmicbias(0);
+		twl5031_disable_pullups();
+
+		aci->eci_callback->event(ECI_EVENT_PLUG_OUT,
+					 aci->eci_callback->priv);
+		cancel_delayed_work_sync(&aci->wd_work);
+		aci_dev_pm_qos_remove_request(&aci->qos_request_acicmd);
+		aci_dev_pm_qos_remove_request(&aci->qos_request_accint);
+
+		mutex_unlock(&aci->acc_block);
+		return;
+	}
+	/* plug on */
+	if (!aci->v28_enabled) {
+		if (regulator_enable(aci->v28))
+			aci->v28_enabled = true;
+	}
+
+	twl5031_aci_set_av_output(aci, ACI_AUDIO);
+
+	aci->accessory = ACI_NOTYPE;
+	aci->previous = ACI_NOTYPE;
+	aci->count = 0;
+	aci->needed = ACI_DETECTS_NEEDED - 1;
+	aci->task = ACI_TASK_DETECTION;
+	aci->detection_count = 0;
+	aci->open_cable_redetects = ACI_OPEN_CABLE_REDETECTS;
+	queue_delayed_work(aci->aci_wq, &aci->aci_work, 0);
+
+	mutex_unlock(&aci->acc_block);
+}
+
+static void twl5031_report_accessory(struct twl5031_aci *aci)
+{
+	dfl61_request_hsmicbias(0);
+
+	switch (aci->accessory) {
+	case ACI_HEADPHONE:
+		twl5031_disable_pullups();
+		aci->detected = "SND_JACK_HEADPHONE";
+		dfl61_jack_report(SND_JACK_HEADPHONE);
+		break;
+	case ACI_AVOUT:
+		twl5031_disable_pullups();
+		aci->detected = "SND_JACK_AVOUT";
+		twl5031_aci_set_av_output(aci, ACI_VIDEO);
+		dfl61_jack_report(SND_JACK_AVOUT);
+		break;
+	case ACI_HEADSET:
+		aci->detected = "SND_JACK_HEADSET";
+		dfl61_jack_report(SND_JACK_HEADSET);
+		aci->task = ACI_TASK_ENABLE_BUTTON;
+		queue_delayed_work(aci->aci_wq, &aci->aci_work,
+				msecs_to_jiffies(ACI_WAIT_PLUG_TO_BUTTONS));
+		break;
+	case ACI_ECI_HEADSET:
+		aci->detected = "ECI as SND_JACK_HEADSET";
+		aci->eci_callback->event(ECI_EVENT_PLUG_IN,
+					 aci->eci_callback->priv);
+		aci->accessory = ACI_ECI_HEADSET;
+		msleep(ACI_BUS_TIMEOUT);
+		/* Now ECI accessory should be initialized, so check buttons */
+		aci->task = ACI_TASK_NONE;
+		twl5031_read_buttons(aci, ECI_BUTTONS_NOT_LATCHED);
+		break;
+	case ACI_OPEN_CABLE:
+		/*
+		 * open cable, ie lineout
+		 * User may plug the other end of the cable in another device.
+		 * Thus, try to re-detect it
+		 * Input system filter out unnecessary events if open cable
+		 * was re-detected
+		 */
+		twl5031_disable_pullups();
+		aci->detected = "AV jack open cable as SND_JACK_LINEOUT";
+		dfl61_jack_report(SND_JACK_LINEOUT);
+
+		if (!aci->open_cable_redetect_enabled)
+			break;
+		if (aci->open_cable_redetects-- > 0) {
+			aci->task = ACI_TASK_DETECTION;
+			aci->needed = ACI_OPEN_CABLE_REDETECTS_NEEDED - 1;
+			queue_delayed_work(aci->aci_wq, &aci->aci_work,
+					msecs_to_jiffies(
+						ACI_OPEN_CABLE_REDETECT_TIMER));
+		}
+		break;
+	case ACI_CARKIT:
+		aci->detected = "Carkit as SND_JACK_HEADPHONE";
+		dfl61_jack_report(SND_JACK_HEADPHONE);
+		aci->task = ACI_TASK_ENABLE_BUTTON;
+		queue_delayed_work(aci->aci_wq, &aci->aci_work,
+				msecs_to_jiffies(ACI_WAIT_PLUG_TO_BUTTONS));
+		break;
+	default:
+		twl5031_disable_pullups();
+		aci->detected = "Unknown AV accessory";
+		dfl61_jack_report(SND_JACK_MECHANICAL);
+		break;
+	}
+	dev_emerg(aci->dev, "%s\n", aci->detected);
+	/* REVISIT Let the madc channel 0 measurements continue
+	twl4030_madc_resume_ch0();*/
+}
+
+/*
+ * aci_work
+ * general work func for several tasks
+ * there is no real race condition using aci->task freely, as tasks can
+ * cancels each others
+ */
+static void twl5031_aci_work(struct work_struct *ws)
+{
+	struct twl5031_aci *aci = container_of(ws, struct twl5031_aci,
+			aci_work.work);
+
+	/* cancel all tasks if plug is already removed */
+	if (!aci->plugged)
+		return;
+
+	switch (aci->task) {
+	case ACI_TASK_ENABLE_BUTTON:
+		twl5031_aci_write(TWL5031_ACIIDR_LSB, ACI_ACCINT);
+		twl5031_aci_enable_irqs(ACI_ACCINT);
+		break;
+	case ACI_TASK_GET_BUTTON:
+		twl5031_get_av_button(aci);
+		break;
+	case ACI_TASK_SEND_BUTTON:
+		twl5031_send_av_button(aci);
+		break;
+	case ACI_TASK_DETECTION:
+		/* REVISIT During the detection MADC channel0 measurement fails
+		twl4030_madc_halt_ch0();*/
+		mutex_lock(&aci->acc_block);
+
+		aci->accessory = twl5031_av_detection(aci);
+
+		mutex_unlock(&aci->acc_block);
+
+		if (aci->previous == aci->accessory)
+			aci->count++;
+		else
+			aci->count = 0;
+
+		aci->previous = aci->accessory;
+
+		/* Needed amount of successive detection results */
+		if (aci->count == aci->needed) {
+			aci->previous = ACI_NOTYPE;
+			twl5031_report_accessory(aci);
+			break;
+		}
+		/* Break out if we never get same successive results */
+		if (aci->detection_count++ > ACI_REDETECTS_BAIL_OUT) {
+			aci->accessory = ACI_UNKNOWN;
+			twl5031_report_accessory(aci);
+			break;
+		}
+
+		/*
+		 * UNKNOWN, HEADPHONE and AVOUT detections are fast. Sleep
+		 * little bit after them. This helps to avoid false detections
+		 */
+		if ((aci->accessory == ACI_HEADPHONE) ||
+			(aci->accessory == ACI_AVOUT) ||
+			(aci->accessory == ACI_UNKNOWN))
+			msleep(ACI_AVOUT_DETECTION_DELAY);
+
+		/* Release ACI HW block */
+		twl5031_disable_pullups();
+		/* REVISIT Let the madc channel 0 measurements continue
+		twl4030_madc_resume_ch0();*/
+		queue_delayed_work(aci->aci_wq, &aci->aci_work, 0);
+		break;
+	default:
+		dev_err(aci->dev, "unknown task %d: %d\n", aci->task, __LINE__);
+		break;
+	}
+}
+
+/*
+ * plug_work - dedicated accessory insert/removal
+ */
+static void twl5031_plug_work(struct work_struct *ws)
+{
+	struct twl5031_aci *aci = container_of(ws, struct twl5031_aci,
+			plug_work.work);
+
+	if (aci->detection_phase == ACI_DETECTION_BIAS_ON) {
+		/* Enable bias to start possible ECI ASIC boot */
+		dfl61_request_hsmicbias(1);
+		aci->detection_phase = ACI_DETECTION_NONE;
+		/* Order actual detection to start */
+		queue_delayed_work(aci->aci_wq, &aci->plug_work,
+				msecs_to_jiffies(ACI_WAIT_PLUG_ON_MIN));
+	} else {
+		twl5031_av_plug_on_off(aci);
+	}
+}
+
+/*
+ * wd_work - recovery watch dog
+ */
+static void twl5031_wd_work(struct work_struct *ws)
+{
+	struct twl5031_aci *aci = container_of(ws, struct twl5031_aci,
+			wd_work.work);
+
+	printk(KERN_ERR "%s\n", __func__);
+
+	mutex_lock(&aci->iolock);
+	aci->task = ACI_TASK_NONE;
+	/* jammed IO read */
+	if (aci->io_read_ongoing) {
+		aci_dev_pm_qos_remove_request(&aci->qos_request_accint);
+
+		/*
+		 * Wait until previous communication is over
+		 * and reset aci block
+		 */
+		twl5031_aci_out_of_coma();
+		aci->cmd = NO_ACICMD;
+		aci->op = ECI_OK;
+		/* This also enables ACCINT */
+		twl5031_emit_buttons(aci, ECI_FORCE_BUTTONS_UP);
+	}
+	mutex_unlock(&aci->iolock);
+}
+
+static ssize_t twl5031_aci_detection_latency_show(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct twl5031_aci *aci = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", aci->detection_latency);
+}
+
+static ssize_t twl5031_aci_detection_latency_store(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf, size_t len)
+{
+	struct  twl5031_aci *aci = dev_get_drvdata(dev);
+	unsigned long latency;
+
+	if (kstrtoul(buf, 0, &latency))
+		return -EINVAL;
+
+	if (latency < ACI_WAIT_PLUG_ON_MIN || latency > ACI_WAIT_PLUG_ON_MAX)
+		return -EINVAL;
+
+	aci->detection_latency = latency;
+	return len;
+}
+
+static DEVICE_ATTR(detection_latency, S_IRUGO | S_IWUSR,
+		twl5031_aci_detection_latency_show,
+		twl5031_aci_detection_latency_store);
+
+static ssize_t twl5031_aci_redetection_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct twl5031_aci *aci = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", aci->open_cable_redetect_enabled);
+}
+
+static ssize_t twl5031_aci_redetection_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	struct  twl5031_aci *aci = dev_get_drvdata(dev);
+	int enable, ret;
+
+	ret = sscanf(buf, "%d", &enable);
+	if (ret < 0)
+		return ret;
+
+	if (ret != 1)
+		return -EINVAL;
+
+	aci->open_cable_redetect_enabled = enable;
+	return len;
+}
+
+static DEVICE_ATTR(periodic_open_cable_redetection_enable, S_IRUGO | S_IWUSR,
+		twl5031_aci_redetection_show,
+		twl5031_aci_redetection_store);
+
+/*
+ * Handle concurrency with acc_block. Refuse to run when plug is inserted,
+ * so no race condition when AV detection logic is in normal use
+ */
+static ssize_t twl5031_aci_selftest_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct  twl5031_aci *aci = dev_get_drvdata(dev);
+	u8 val, orig_av_ctrl, orig_eci_dbi_ctrl;
+	ssize_t len;
+
+	if (aci->plugged)
+		return sprintf(buf, "AV plug inserted, not running selftest\n");
+
+	mutex_lock(&aci->acc_block);
+	/* REVISIT During the selftest MADC channel0 measurement fails
+	twl4030_madc_halt_ch0();*/
+
+	orig_av_ctrl = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+	orig_eci_dbi_ctrl = twl5031_aci_read(TWL5031_ECI_DBI_CTRL);
+
+	/* drive HSMIC.DC low */
+	dfl61_request_hsmicbias(0);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_ENABLE | ACI_DBI_MODE);
+
+	/* Ground HSMIC line to discharge capasitors */
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, HSM_GROUNDED_EN);
+	msleep(ACI_WAIT_VOLTAGE_SETTLING);
+	/* Remove grounding of the line */
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, 0);
+	msleep(ACI_WAIT_VOLTAGE_SETTLING);
+
+	/* Measure */
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, AV_COMP1_EN);
+	usleep_range(ACI_WAIT_COMPARATOR_SETTLING_LO,
+		ACI_WAIT_COMPARATOR_SETTLING_HI);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	if ((val & STATUS_A1_COMP) != AV_BELOW_600mV) {
+		len = sprintf(buf, "FAILED\n can not drive HSMIC.DC low\n");
+		goto out;
+	}
+
+	/* drive HSMIC.DC high with sleep mode LDO */
+	val = AV_COMP1_EN | HOOK_DET_EN | HOOK_DET_EN_SLEEP_MODE;
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, val);
+	usleep_range(ACI_WAIT_COMPARATOR_SETTLING_LO,
+		ACI_WAIT_COMPARATOR_SETTLING_HI);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	if ((val & STATUS_A1_COMP) != AV_ABOVE_600mV) {
+		len = sprintf(buf, "FAILED\n can not drive HSMIC.DC high\n");
+		goto out;
+	}
+
+	/* drive HSMIC.DC high with MIC bias */
+	val &= ~HOOK_DET_EN_SLEEP_MODE;
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, val);
+	dfl61_request_hsmicbias(1);
+	usleep_range(ACI_WAIT_COMPARATOR_SETTLING_LO,
+		ACI_WAIT_COMPARATOR_SETTLING_HI);
+	val = twl5031_aci_read(TWL5031_ACI_AV_CTRL);
+
+	if ((val & STATUS_A1_COMP) != AV_ABOVE_600mV) {
+		len = sprintf(buf, "FAILED\n can not drive HSMIC.DC high\n");
+		goto out;
+	}
+	len = sprintf(buf, "OK\n");
+out:
+	dfl61_request_hsmicbias(0);
+	twl5031_aci_write(TWL5031_ACI_AV_CTRL, orig_av_ctrl);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, orig_eci_dbi_ctrl);
+
+	/* REVISIT Let the madc channel 0 measurements continue
+	twl4030_madc_resume_ch0(); */
+	mutex_unlock(&aci->acc_block);
+
+	return len;
+}
+
+static DEVICE_ATTR(selftest, S_IRUGO, twl5031_aci_selftest_show, NULL);
+
+static struct attribute *sysfs_attrs_ctrl[] = {
+	&dev_attr_detection_latency.attr,
+	&dev_attr_periodic_open_cable_redetection_enable.attr,
+	&dev_attr_selftest.attr,
+	NULL
+};
+
+static struct attribute_group twl5031_aci_attr_group = {
+	.attrs = sysfs_attrs_ctrl
+};
+
+static int is_twl5031_aci(struct twl5031_aci *aci)
+{
+	u8 i;
+
+	/* Do not change order unless ACI HW is changed */
+	struct {
+		u8 sync0;
+		u8 sync1;
+		u8 vcpr;
+		u8 vcnum;
+		u8 vcver;
+		u8 masize;
+		u8 mdsize;
+		u8 mfsize;
+		u8 log_byte_count;
+		u8 sync0_rep;
+	} aciid;
+
+	u8 *byte = &aciid.sync0;
+
+	/* REVISIT:
+	 * twl5031 silicon rev. ES 1.0 and ES 1.1 have ACI/ECI bug
+	 * Any writes on 0x74-0x7E of any address group
+	 * will affect same ACI/ECI registers.
+	 * Workaround *MUST* be implemented in twl-core.c
+	 */
+	if ((twl_get_type() & 0xffff) == 0x802f) {
+		int version = twl_get_version();
+		if (version == 0x1b || version == 0x0b) {
+			dev_err(aci->dev, "Buggy ECI found: patch to twl-core.c needed!\n");
+			return -ENODEV;
+		};
+	}
+
+	/* set index to the ACI ID system */
+	twl5031_aci_write(TWL5031_ACIID, 0);
+	for (i = 0; i < sizeof(aciid); i++) {
+		*byte = twl5031_aci_read(TWL5031_ACIID);
+		byte++;
+	}
+
+	if ((aciid.sync0 == 0x55) && (aciid.sync1 == 0xaa) &&
+						(aciid.sync0_rep == 0x55)) {
+		dev_info(aci->dev, "found twl5031 ACI v.%d\n",  aciid.vcver);
+		aci->version = aciid.vcver;
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static struct miscdevice twl5031_aci_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = ACI_DRIVERNAME,
+};
+
+static struct eci_hw_ops twl5031_aci_hw_ops = {
+	.acc_reset			= twl5031_acc_reset,
+	.acc_read_direct	= twl5031_acc_read_direct,
+	.acc_read_reg		= twl5031_acc_read_reg,
+	.acc_write_reg		= twl5031_acc_write_reg,
+};
+
+static int twl5031_aci_probe(struct platform_device *pdev)
+{
+	struct twl5031_aci *aci;
+	struct twl5031_aci_data *pdata = pdev->dev.platform_data;
+	struct device_node *np = pdev->dev.of_node;
+	int irq;
+	int ret;
+
+	aci = devm_kzalloc(&pdev->dev, sizeof(*aci), GFP_KERNEL);
+	if (!aci)
+		return -ENOMEM;
+
+	if (pdata) {
+		aci->tvout_gpio = pdata->tvout_gpio;
+		aci->jack_gpio = pdata->jack_gpio;
+		aci->avplugdet_plugged = pdata->avplugdet_plugged;
+	} else if (np) {
+		/*struct device_node *audio_node, *codec_node;
+		struct platform_device *codec_pdev;*/
+
+		ret = of_get_named_gpio(np, "tvout_en_gpio", 0);
+		if (ret < 0) {
+			dev_err(&pdev->dev,
+				"Failed to request tvout_en_gpio: %d\n", ret);
+			return ret;
+		}
+		aci->tvout_gpio = ret;
+
+		ret = of_get_named_gpio(np, "jack_gpio", 0);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to request jack_gpio: %d\n", ret);
+			return ret;
+		}
+		aci->jack_gpio = ret;
+
+		/*audio_node = of_find_compatible_node(np->parent, NULL,
+												"ti,twl4030-audio");
+		if (!audio_node) {
+			dev_err(&pdev->dev, "Failed to find twl4030-audio node\n");
+			return -ENODEV;
+		}
+
+		codec_node = of_find_node_by_name(audio_node, "codec");
+		if (!codec_node) {
+			dev_err(&pdev->dev, "Failed to find twl4030-codec node\n");
+			return -ENODEV;
+		}
+
+		codec_pdev = of_find_device_by_node(codec_node);
+		if (!codec_pdev) {
+			dev_warn(&pdev->dev, "Failed to find twl4030-codec node\n");
+			return -EPROBE_DEFER;
+		}
+
+		codec_component = soc_find_component(codec_node, "twl4030-codec");
+		if (!codec_component) {
+			dev_err(&pdev->dev,
+					"Failed to find twl4030-codec component node\n");
+			return -EPROBE_DEFER;
+		}*/
+
+		of_property_read_s32(np, "avplugdet_plugged",
+			&aci->avplugdet_plugged);
+	} else {
+		dev_err(&pdev->dev, "platform_data not available\n");
+		return -EINVAL;
+	}
+
+	platform_set_drvdata(pdev, aci);
+	aci->dev = &pdev->dev;
+
+	twl_set_regcache_bypass(TWL5031_MODULE_ACCESSORY, true); //FIXME
+
+	aci->v28 = devm_regulator_get(&pdev->dev, "v28");
+	if (IS_ERR(aci->v28)) {
+		dev_err(&pdev->dev, "Failed to request v28 supply\n");
+		return -ENODEV;
+	}
+	aci->v28_enabled = false;
+
+	ret = devm_gpio_request(&pdev->dev, aci->tvout_gpio,
+							"ACI TVOUT_EN");
+	if (ret)
+		dev_err(&pdev->dev, "could not request TVOUT_EN gpio: %d\n",
+				aci->tvout_gpio);
+
+	gpio_direction_output(aci->tvout_gpio, 0);
+
+	ret = devm_gpio_request(&pdev->dev, aci->jack_gpio, "AvPlugDet");
+	if (ret)
+		dev_err(&pdev->dev, "could not request AvPlugDet gpio: %d\n",
+				aci->jack_gpio);
+
+	aci->detected = "AV jack not plugged yet";
+	aci->detection_latency = ACI_WAIT_PLUG_ON_DEFAULT;
+	aci->detection_phase = ACI_DETECTION_NONE;
+	aci->open_cable_redetects = ACI_OPEN_CABLE_REDETECTS;
+	aci->open_cable_redetect_enabled = true;
+	aci->data.buf = aci->buf;
+
+	ret = dfl61_request_hsmicbias(0);
+	if (ret == -EPROBE_DEFER)
+		return ret;
+
+	the_aci = aci;
+
+	/* force reset to ACI ASIC. Disable all ACI irqs by default */
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_DISABLE | ACI_DBI_MODE);
+
+	if (is_twl5031_aci(aci)) {
+		dev_err(&pdev->dev, "twl5031 ACI not found\n");
+		ret = -ENODEV;
+		goto err_aci;
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &twl5031_aci_attr_group);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Sysfs registration failed\n");
+		goto err_sysfs;
+	}
+
+	ret = misc_register(&twl5031_aci_device);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register misc_device\n");
+		goto err_misc_register;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+									twl5031_aci_irq_thread,
+									0, dev_name(aci->dev)
+									,aci);
+	if (ret) {
+		dev_err(&pdev->dev, "could not request ACI irq %d\n", irq);
+		goto err_aci_irq;
+	}
+
+	aci->aci_wq = create_singlethread_workqueue("aci");
+	if (aci->aci_wq == NULL) {
+		dev_err(&pdev->dev, "couldn't create aci workqueue\n");
+		ret = -ENOMEM;
+		goto err_wq;
+	}
+	INIT_DELAYED_WORK(&aci->aci_work, twl5031_aci_work);
+	INIT_DELAYED_WORK(&aci->plug_work, twl5031_plug_work);
+	INIT_DELAYED_WORK(&aci->wd_work, twl5031_wd_work);
+	INIT_WORK(&aci->irq_work, twl5031_irq_work);
+
+	ret = aci_initialize_debugfs(aci);
+	if (!ret)
+		dev_err(&pdev->dev, "could not create debugfs entries\n");
+
+	/* Register to ACI and ECI input drivers */
+	aci->aci_callback = aci_register();
+	if (IS_ERR(aci->aci_callback)) {
+		ret = PTR_ERR(aci->aci_callback);
+		goto err_aci_register;
+	}
+
+	aci->eci_callback = eci_register(&twl5031_aci_hw_ops);
+	if (IS_ERR(aci->eci_callback)) {
+		ret = PTR_ERR(aci->eci_callback);
+		goto err_eci_register;
+	}
+
+	mutex_init(&aci->lock);
+	mutex_init(&aci->iolock);
+	mutex_init(&aci->acc_block);
+	spin_lock_init(&aci->irqlock);
+	init_waitqueue_head(&aci->wait);
+
+	aci->avswitch = ACI_AUDIO;
+	twl5031_aci_set_av_output(aci, ACI_AUDIO);
+
+	dfl61_request_hsmicbias(0);
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_DISABLE | ACI_DBI_MODE);
+
+	aci->io_read_ongoing = 0;
+
+	/*
+	 * this trick to get interrupt from already inserted plug
+	 * there is serial resistor between gpio out and AV-connector,
+	 * so this is OK thing to do
+	 */
+	gpio_direction_output(aci->jack_gpio, !aci->avplugdet_plugged);
+
+	ret = devm_request_threaded_irq(&pdev->dev,
+			gpio_to_irq(aci->jack_gpio), NULL,
+			twl5031_plugdet_irq_handler, IRQF_TRIGGER_FALLING |
+			IRQF_TRIGGER_RISING, "AvPlugDet", aci);
+	if (ret) {
+		dev_err(&pdev->dev, "could not request irq: %d\n", irq);
+		goto err_jack_irq;
+	}
+
+	/*
+	 * It seems to be necessary to wait here about a millisecond,
+	 * otherwise an interrupt gets lost. The reason is unknown.
+	 */
+	usleep_range(1000, 1100);
+	/*
+	 * if plug was already inserted, this should trigger interrupt,
+	 * as line was set high earlier
+	 */
+	aci->accessory = ACI_UNKNOWN;
+	gpio_direction_input(aci->jack_gpio);
+
+	return 0;
+
+err_jack_irq:
+err_eci_register:
+	/* unregister if implemented */
+err_aci_register:
+	aci_uninitialize_debugfs();
+	destroy_workqueue(aci->aci_wq);
+err_wq:
+	gpio_direction_input(aci->tvout_gpio);
+	twl5031_aci_disable_irqs(ACI_INTERNAL | ACI_ACCINT);
+err_aci_irq:
+	misc_deregister(&twl5031_aci_device);
+
+err_misc_register:
+	sysfs_remove_group(&pdev->dev.kobj, &twl5031_aci_attr_group);
+err_sysfs:
+err_aci:
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_DISABLE | ACI_DBI_MODE);
+
+	return ret;
+}
+
+
+static int twl5031_aci_remove(struct platform_device *pdev)
+{
+	struct twl5031_aci_data *pdata = pdev->dev.platform_data;
+	struct twl5031_aci *aci = platform_get_drvdata(pdev);
+
+	twl5031_aci_disable_irqs(ACI_INTERNAL | ACI_ACCINT);
+	cancel_delayed_work_sync(&aci->aci_work);
+	cancel_delayed_work_sync(&aci->plug_work);
+	cancel_delayed_work_sync(&aci->wd_work);
+	cancel_work_sync(&aci->irq_work);
+	destroy_workqueue(aci->aci_wq);
+	aci_dev_pm_qos_remove_request(&aci->qos_request_acicmd);
+	aci_dev_pm_qos_remove_request(&aci->qos_request_accint);
+	twl5031_aci_set_av_output(aci, ACI_VIDEO);
+	dfl61_request_hsmicbias(0);
+	twl5031_disable_pullups();
+	gpio_direction_input(pdata->tvout_gpio);
+	free_irq(gpio_to_irq(pdata->jack_gpio), aci);
+	if (aci->v28_enabled)
+		regulator_disable(aci->v28);
+	aci_uninitialize_debugfs();
+	misc_deregister(&twl5031_aci_device);
+	sysfs_remove_group(&pdev->dev.kobj, &twl5031_aci_attr_group);
+
+	twl5031_aci_write(TWL5031_ECI_DBI_CTRL, ACI_DISABLE | ACI_DBI_MODE);
+	return 0;
+}
+
+static const struct of_device_id twl5031_aci_of_match[] = {
+	{.compatible = "ti,twl5031-aci", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, twl5031_aci_of_match);
+
+static struct platform_driver twl5031_aci_driver = {
+	.probe		= twl5031_aci_probe,
+	.remove		= twl5031_aci_remove,
+	.driver		= {
+		.name	= ACI_DRIVERNAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= twl5031_aci_of_match,
+	},
+};
+module_platform_driver(twl5031_aci_driver);
+
+MODULE_ALIAS("platform:twl5031-aci");
+MODULE_AUTHOR("Nokia Corporation");
+MODULE_DESCRIPTION("twl5031 ACI driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/i2c/twl.h b/include/linux/i2c/twl.h
index 6547d302c3b8..7dcc1d3a345c 100644
--- a/include/linux/i2c/twl.h
+++ b/include/linux/i2c/twl.h
@@ -96,6 +96,7 @@ enum twl6030_module_ids {
 #define MADC_INTR_OFFSET	3
 #define USB_INTR_OFFSET		4
 #define CHARGERFAULT_INTR_OFFSET 5
+#define ACI_INTR_OFFSET		6
 #define BCI_PRES_INTR_OFFSET	9
 #define USB_PRES_INTR_OFFSET	10
 #define RTC_INTR_OFFSET		11
@@ -705,6 +706,15 @@ struct twl4030_audio_data {
	unsigned int irq_base;
 };

+struct twl5031_aci_data {
+	int	tvout_gpio;
+	int	jack_gpio;
+
+#define AVPLUGDET_WHEN_PLUGGED_LOW 0
+#define AVPLUGDET_WHEN_PLUGGED_HIGH 1
+	int	avplugdet_plugged;
+};
+
 struct twl4030_platform_data {
	struct twl4030_clock_init_data		*clock;
	struct twl4030_bci_platform_data	*bci;
@@ -714,6 +724,7 @@ struct twl4030_platform_data {
	struct twl4030_usb_data			*usb;
	struct twl4030_power_data		*power;
	struct twl4030_audio_data		*audio;
+	struct twl5031_aci_data			*aci;

	/* Common LDO regulators for TWL4030/TWL6030 */
	struct regulator_init_data		*vdac;
diff --git a/include/linux/input/eci.h b/include/linux/input/eci.h
new file mode 100644
index 000000000000..4015437db7d4
--- /dev/null
+++ b/include/linux/input/eci.h
@@ -0,0 +1,96 @@
+/*
+ * This file is part of ECI (Enhancement Control Interface) driver
+ *
+ * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * Contact: Tapio Vihuri <tapio.vihuri@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+#ifndef __ECI_H__
+#define __ECI_H__
+
+#include <sound/n9.h>
+
+#define ECI_MAX_MEM_SIZE	0x7c
+#define ECI_BUTTON_BUF_SIZE	32
+#define ECI_MAX_FEATURE_COUNT	31
+
+struct eci_hw_ops {
+	int (*acc_reset)(void);
+	int (*acc_read_direct)(u8 addr, char *buf);
+	int (*acc_read_reg)(u8 reg, u8 *buf, int count);
+	int (*acc_write_reg)(u8 reg, u8 param);
+};
+
+struct aci_cb {
+	void *priv;
+	void (*button_event)(bool button_down, void *priv);
+};
+
+struct eci_cb {
+	void *priv;
+	void (*event)(int event, void *priv);
+};
+
+struct eci_platform_data {
+	void (*register_hsmic_event_cb)(struct dfl61audio_hsmic_event *);
+	void (*jack_report) (int status);
+};
+
+struct enhancement_features_fixed {
+	u8	block_id;
+	u8	length;
+	u8	connector_conf;
+	u8	number_of_features;
+};
+
+struct enhancement_features_variable {
+	u8	*io_support;
+	u8	*io_functionality;
+	u8	*active_state;
+};
+
+struct eci_buttons_data {
+	u32	buttons;
+	int	windex;
+	int	rindex;
+	u32	buttons_up_mask;
+	u32	buttons_buf[ECI_BUTTON_BUF_SIZE];
+};
+
+struct eci_data {
+	struct device                           *dev;
+	struct delayed_work                     eci_ws;
+	wait_queue_head_t                       wait;
+	struct input_dev                        *acc_input;
+	int                                     event;
+	bool                                    mem_ok;
+	u16                                     mem_size;
+	u8                                      memory[ECI_MAX_MEM_SIZE];
+	struct enhancement_features_fixed      *e_features_fix;
+	struct enhancement_features_variable   e_features_var;
+	u8					port_reg_count;
+	struct eci_buttons_data			buttons_data;
+	struct eci_hw_ops                       *eci_hw_ops;
+	u8					mic_state;
+
+	void (*jack_report) (int status);
+};
+
+struct aci_cb *aci_register(void);
+struct eci_cb *eci_register(struct eci_hw_ops *eci_ops);
+#endif
diff --git a/include/linux/mfd/twl5031-aci.h b/include/linux/mfd/twl5031-aci.h
new file mode 100644
index 000000000000..89eeea68812d
--- /dev/null
+++ b/include/linux/mfd/twl5031-aci.h
@@ -0,0 +1,149 @@
+/*
+ * This file is part of twl5031 ACI (Accessory Control Interface) driver
+ *
+ * Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * Contact: Tapio Vihuri <tapio.vihuri@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+#ifndef __ACI_H__
+#define __ACI_H__
+
+/*
+ * Accessory block register offsets (use TWL5031_MODULE_ACCESSORY)
+ */
+#define TWL5031_ACIID			0x0
+#define TWL5031_ACICOMR_LSB		0x1
+#define TWL5031_ACICOMR_MSB		0x2
+#define TWL5031_ACITXDAR		0x3
+#define TWL5031_ACIRXDAR		0x4
+#define TWL5031_ACISPLR			0x9
+#define TWL5031_ACIITR			0xA
+#define TWL5031_ECI_DBI_CTRL		0xB
+#define TWL5031_ACI_AV_CTRL		0xC
+#define TWL5031_ACI_AUDIO_CTRL		0xD
+#define TWL5031_ACI_BCIA_CTRL		0xE
+#define TWL5031_ACCSIR			0x13
+
+/* TWL5031_ACIIxR_xSB bits, ie. ACI IDR/IMR types */
+#define ACI_ACCINT	0x001
+#define ACI_DREC	0x002
+#define ACI_DSENT	0x004
+#define ACI_SPDSET	0x008
+#define ACI_COMMERR	0x010
+#define ACI_FRAERR	0x020
+#define ACI_RESERR	0x040
+#define ACI_COLL	0x080
+#define ACI_NOPINT	0x100
+#define ACI_INTERNAL	(ACI_DREC | ACI_DSENT | ACI_SPDSET | ACI_COMMERR | \
+			ACI_FRAERR | ACI_RESERR | ACI_COLL | ACI_NOPINT)
+
+/* TWL5031_ACI_AV_CTRL bits */
+#define AV_COMP1_EN		0x01
+#define AV_COMP2_EN		0x02
+#define ADC_SW_EN		0x04
+#define STATUS_A1_COMP		0x08
+#define STATUS_A2_COMP		0x10
+#define HOOK_DET_EN		0x20
+#define HOOK_DET_EN_SLEEP_MODE	0x40
+#define HSM_GROUNDED_EN		0x80
+
+/* TWL5031_ACI_AV_CTRL bits */
+#define HOOK_DEB_BYPASS		0x10
+
+/*----------------------------------------------------------------------*/
+
+/* TWL4030_REG_MICBIAS_CTL bits */
+#define HSMICBIAS_EN	0x04
+
+/* TWL5031_ECI_DBI_CTRL bit */
+#define ACI_DBI_MODE		(0 << 0)
+#define ACI_ACCESSORY_MODE	(1 << 0)
+#define ACI_ENABLE		(0 << 1)
+#define ACI_DISABLE		(1 << 1)
+
+/* fixed in ECI HW, do not change */
+enum {
+	ECICMD_HWID,
+	ECICMD_SWID,
+	ECICMD_ECI_BUS_SPEED,
+	ECICMD_MIC_CTRL,
+	ECICMD_MASTER_INT_REG,
+	ECICMD_HW_CONF_MEM_ACCESS,
+	ECICMD_EXTENDED_MEM_ACCESS,
+	ECICMD_INDIRECT_MEM_ACCESS,
+	ECICMD_PORT_DATA_0,
+	ECICMD_PORT_DATA_1,
+	ECICMD_PORT_DATA_2,
+	ECICMD_PORT_DATA_3,
+	ECICMD_LATCHED_PORT_DATA_0,
+	ECICMD_LATCHED_PORT_DATA_1,
+	ECICMD_LATCHED_PORT_DATA_2,
+	ECICMD_LATCHED_PORT_DATA_3,
+	ECICMD_DATA_DIR_0,
+	ECICMD_DATA_DIR_1,
+	ECICMD_DATA_DIR_2,
+	ECICMD_DATA_DIR_3,
+	ECICMD_INT_CONFIG_0_LOW,
+	ECICMD_INT_CONFIG_0_HIGH,
+	ECICMD_INT_CONFIG_1_LOW,
+	ECICMD_INT_CONFIG_1_HIGH,
+	ECICMD_INT_CONFIG_2_LOW,
+	ECICMD_INT_CONFIG_2_HIGH,
+	ECICMD_INT_CONFIG_3_LOW,
+	ECICMD_INT_CONFIG_3_HIGH,
+	/* 0x1c-0x2f reserved for future */
+	ECICMD_EEPROM_LOCK = 0x3e,
+	ECICMD_DUMMY = 0xff,
+	ECICMD_PARAM1,
+};
+
+/* ECI accessory register's bits */
+#define ECI_MIC_AUTO	0x00
+#define ECI_MIC_OFF	0x5a
+#define ECI_MIC_ON	0xff
+
+#define ECI_INT_ENABLE		1
+#define ECI_INT_DELAY_ENABLE	(1 << 1)
+#define ECI_INT_LEN_76MS	0
+#define ECI_INT_LEN_82MS	(1 << 5)
+#define ECI_INT_LEN_37MS	(2 << 5)
+#define ECI_INT_LEN_19MS	(3 << 5)
+#define ECI_INT_LEN_10MS	(4 << 5)
+#define ECI_INT_LEN_5MS		(5 << 5)
+#define ECI_INT_LEN_2MS		(6 << 5)
+#define ECI_INT_LEN_120US	(7 << 5)
+
+enum {
+	ECI_EVENT_PLUG_IN,
+	ECI_EVENT_PLUG_OUT,
+	ECI_EVENT_BUTTON,
+	ECI_EVENT_NO,
+};
+
+enum{
+	ECI_DISABLED,
+	ECI_ENABLED,
+};
+
+/* misc ACI defines */
+#define ACI_MADC_CHANNEL	10
+
+void twl5031_aci_register(void (*aci_cb)(bool button_down, void *priv),
+		void *priv);
+void twl5031_eci_register(void (*eci_cb)(int event, void *priv), void *priv);
+#endif
diff --git a/include/sound/n9.h b/include/sound/n9.h
new file mode 100644
index 000000000000..22e9725e82b7
--- /dev/null
+++ b/include/sound/n9.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2009 Nokia
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _N9_H_
+#define _N9_H_
+
+struct dfl61audio_hsmic_event {
+	void *private;
+	void (*event)(void *priv, bool on);
+};
+
+void dfl61_jack_report(int status);
+int dfl61_request_hsmicbias(bool enable);
+void dfl61_register_hsmic_event_cb(struct dfl61audio_hsmic_event *event);
+int dfl61_request_hp_enable(bool enable);
+#endif
diff --git a/sound/soc/omap/n9.c b/sound/soc/omap/n9.c
index 7fbcb79e6a55..df5dbb2b2d80 100644
--- a/sound/soc/omap/n9.c
+++ b/sound/soc/omap/n9.c
@@ -40,6 +40,7 @@

 #include <asm/mach-types.h>

+#include <sound/n9.h>
 #include "omap-mcbsp.h"
 #include "mcbsp.h"

@@ -58,6 +59,7 @@ static int dfl61dac33_interconnect_enable(int);
 static struct snd_soc_card dfl61dac33_sound_card;
 static struct snd_soc_card dfl61twl_sound_card;
 static struct snd_soc_jack dfl61_jack;
+static struct dfl61audio_hsmic_event *hsmic_event;

 static struct snd_soc_component *find_component(struct snd_soc_card *card) {
	struct snd_soc_component *component;
@@ -124,6 +126,12 @@ int dfl61_request_hsmicbias(bool enable)
 }
 EXPORT_SYMBOL(dfl61_request_hsmicbias);

+void dfl61_register_hsmic_event_cb(struct dfl61audio_hsmic_event *event)
+{
+	hsmic_event = event;
+}
+EXPORT_SYMBOL(dfl61_register_hsmic_event_cb);
+
 static int dfl61twl_hw_params(struct snd_pcm_substream *substream,
	struct snd_pcm_hw_params *params)
 {
@@ -187,6 +195,20 @@ static int dfl61twl_tlv320dac33_event(struct snd_soc_dapm_widget *w,
	return r;
 }

+static int dfl61twl_hsmic_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	if (!hsmic_event || !hsmic_event->event)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		hsmic_event->event(hsmic_event->private, 1);
+	else
+		hsmic_event->event(hsmic_event->private, 0);
+
+	return 0;
+}
+
 /* DAPM widgets and routing for TWL4030 */
 static const struct snd_soc_dapm_widget dfl61twl_dapm_widgets[] = {
	SND_SOC_DAPM_SPK("Ext Spk", dfl61twl_spk_event),
@@ -196,7 +218,7 @@ static const struct snd_soc_dapm_widget dfl61twl_dapm_widgets[] = {
	SND_SOC_DAPM_SPK("DAC33 interconnect", dfl61twl_tlv320dac33_event),

	SND_SOC_DAPM_MIC("Digital Mic", NULL),
-	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", dfl61twl_hsmic_event),

	SND_SOC_DAPM_LINE("FMRX Left Line-in", NULL),
	SND_SOC_DAPM_LINE("FMRX Right Line-in", NULL),
--
2.11.0
