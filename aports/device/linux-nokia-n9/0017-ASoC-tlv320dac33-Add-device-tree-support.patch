From 71e8bfce78c62ae748a5d27ea024ad70fd675d64 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Filip=20Matijevi=C4=87?= <filip.matijevic.pz@gmail.com>
Date: Thu, 24 Dec 2015 16:02:08 +0100
Subject: [PATCH 17/53] ASoC: tlv320dac33: Add device tree support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Filip MatijeviÄ‡ <filip.matijevic.pz@gmail.com>
---
 .../devicetree/bindings/sound/tlv320dac33.txt      | 39 ++++++++++++++++++++
 sound/soc/codecs/tlv320dac33.c                     | 41 ++++++++++++++++------
 2 files changed, 69 insertions(+), 11 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/tlv320dac33.txt

diff --git a/Documentation/devicetree/bindings/sound/tlv320dac33.txt b/Documentation/devicetree/bindings/sound/tlv320dac33.txt
new file mode 100644
index 000000000000..6e8889071d6f
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/tlv320dac33.txt
@@ -0,0 +1,39 @@
+Texas Instruments - tlv320dac33 Codec module
+
+The tlv320dac33 serial control bus communicates through I2C protocols
+
+Required properties:
+
+- compatible - "ti,tlv320dac33"
+- reg - I2C slave address
+
+Optional properties:
+
+- power-gpio - gpio pin number used for codec reset
+
+- AVDD-supply, DVDD-supply, IOVDD-supply: power supplies for the device as covered
+  in Documentation/devicetree/bindings/regulator/regulator.txt
+
+- interrupts       - The interrupt output from the device.
+- interrupt-parent - The parent interrupt controller.
+
+- keep_bclk 	- Keep the BCLK running in FIFO modes
+- burst_bclkdiv - BCLK divider value in burst mode
+
+Example:
+
+tlv320dac33: tlv320dac33@19 {
+	compatible = "ti,tlv320dac33";
+	reg = <0x19>;
+
+	AVDD-supply = <&vaux4>;
+	DVDD-supply = <&vio>;
+	IOVDD-supply = <&vio>;
+
+	interrupt-parent = <&gpio2>;
+	interrupts = <21 1>; /* gpio_53, IRQF_TRIGGER_RISING*
+	power-gpio = <&gpio2 28 0>; /* gpio_60 */
+
+	keep_bclk;
+	burst_bclkdiv = /bits/ 8 <3>;
+};
diff --git a/sound/soc/codecs/tlv320dac33.c b/sound/soc/codecs/tlv320dac33.c
index 7bcf01efdf9a..f7ce389894e4 100644
--- a/sound/soc/codecs/tlv320dac33.c
+++ b/sound/soc/codecs/tlv320dac33.c
@@ -30,6 +30,7 @@
 #include <linux/interrupt.h>
 #include <linux/gpio.h>
 #include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
 #include <linux/slab.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -1484,16 +1485,11 @@ static struct snd_soc_dai_driver dac33_dai = {
 static int dac33_i2c_probe(struct i2c_client *client,
			   const struct i2c_device_id *id)
 {
-	struct tlv320dac33_platform_data *pdata;
+	struct tlv320dac33_platform_data *pdata = client->dev.platform_data;
	struct tlv320dac33_priv *dac33;
+	struct device_node *np = client->dev.of_node;
	int ret, i;

-	if (client->dev.platform_data == NULL) {
-		dev_err(&client->dev, "Platform data not set\n");
-		return -ENODEV;
-	}
-	pdata = client->dev.platform_data;
-
	dac33 = devm_kzalloc(&client->dev, sizeof(struct tlv320dac33_priv),
			     GFP_KERNEL);
	if (dac33 == NULL)
@@ -1505,10 +1501,26 @@ static int dac33_i2c_probe(struct i2c_client *client,

	i2c_set_clientdata(client, dac33);

-	dac33->power_gpio = pdata->power_gpio;
-	dac33->burst_bclkdiv = pdata->burst_bclkdiv;
-	dac33->keep_bclk = pdata->keep_bclk;
-	dac33->mode1_latency = pdata->mode1_latency;
+	if (pdata) {
+		dac33->power_gpio = pdata->power_gpio;
+		dac33->burst_bclkdiv = pdata->burst_bclkdiv;
+		dac33->keep_bclk = pdata->keep_bclk;
+		dac33->mode1_latency = pdata->mode1_latency;
+	} else if (np) {
+		ret = of_get_named_gpio(np, "power-gpio", 0);
+		if (ret >= 0)
+			dac33->power_gpio = ret;
+		else
+			dac33->power_gpio = -1;
+
+		if (of_property_read_bool(np, "keep_bclk"))
+			dac33->keep_bclk = true;
+
+		of_property_read_u8(np, "burst_bclkdiv", &dac33->burst_bclkdiv);
+	} else {
+		dev_err(&client->dev, "Platform data not set\n");
+		return -ENODEV;
+	}
	if (!dac33->mode1_latency)
		dac33->mode1_latency = 10000; /* 10ms */
	dac33->irq = client->irq;
@@ -1574,9 +1586,16 @@ static const struct i2c_device_id tlv320dac33_i2c_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, tlv320dac33_i2c_id);

+static const struct of_device_id tlv320dac33_of_match[] = {
+	{ .compatible = "ti,tlv320dac33", },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, tlv320dac33_of_match);
+
 static struct i2c_driver tlv320dac33_i2c_driver = {
	.driver = {
		.name = "tlv320dac33-codec",
+		.of_match_table = of_match_ptr(tlv320dac33_of_match),
	},
	.probe		= dac33_i2c_probe,
	.remove		= dac33_i2c_remove,
--
2.11.0
